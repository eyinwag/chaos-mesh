/* tslint:disable */
/* eslint-disable */
/**
 * Chaos Mesh Dashboard API
 * Swagger for Chaos Mesh Dashboard. If you encounter any problems with API, please click on the issues link below to report.
 *
 * The version of the OpenAPI document: 2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from './base'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common'
import globalAxios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios'

import { Configuration } from './configuration'

/**
 *
 * @export
 * @interface ArchiveDetail
 */
export interface ArchiveDetail {
  /**
   *
   * @type {CoreKubeObjectDesc}
   * @memberof ArchiveDetail
   */
  kube_object?: CoreKubeObjectDesc
}
/**
 *
 * @export
 * @interface CommonPhysicalMachine
 */
export interface CommonPhysicalMachine {
  /**
   *
   * @type {string}
   * @memberof CommonPhysicalMachine
   */
  address?: string
  /**
   *
   * @type {string}
   * @memberof CommonPhysicalMachine
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CommonPhysicalMachine
   */
  namespace?: string
}
/**
 *
 * @export
 * @interface CommonPod
 */
export interface CommonPod {
  /**
   *
   * @type {string}
   * @memberof CommonPod
   */
  ip?: string
  /**
   *
   * @type {string}
   * @memberof CommonPod
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CommonPod
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof CommonPod
   */
  state?: string
}
/**
 *
 * @export
 * @interface ConfigChaosDashboardConfig
 */
export interface ConfigChaosDashboardConfig {
  /**
   * ClusterScoped means control Chaos Object in cluster level(all namespace).
   * @type {boolean}
   * @memberof ConfigChaosDashboardConfig
   */
  cluster_mode?: boolean
  /**
   *
   * @type {boolean}
   * @memberof ConfigChaosDashboardConfig
   */
  dns_server_create?: boolean
  /**
   * EnableFilterNamespace will filter namespace with annotation. Only the pods/containers in namespace annotated with `chaos-mesh.org/inject=enabled` will be injected.
   * @type {boolean}
   * @memberof ConfigChaosDashboardConfig
   */
  enableFilterNamespace?: boolean
  /**
   * GcpSecurityMode will use the gcloud authentication to login to GKE user
   * @type {boolean}
   * @memberof ConfigChaosDashboardConfig
   */
  gcp_security_mode?: boolean
  /**
   *
   * @type {string}
   * @memberof ConfigChaosDashboardConfig
   */
  listen_host?: string
  /**
   *
   * @type {number}
   * @memberof ConfigChaosDashboardConfig
   */
  listen_port?: number
  /**
   *
   * @type {string}
   * @memberof ConfigChaosDashboardConfig
   */
  root_path?: string
  /**
   * SecurityMode will use the token login by the user if set to true
   * @type {boolean}
   * @memberof ConfigChaosDashboardConfig
   */
  security_mode?: boolean
  /**
   * TargetNamespace is the target namespace to injecting chaos. It only works with ClusterScoped is false.
   * @type {string}
   * @memberof ConfigChaosDashboardConfig
   */
  target_namespace?: string
  /**
   *
   * @type {string}
   * @memberof ConfigChaosDashboardConfig
   */
  version?: string
}
/**
 *
 * @export
 * @interface CoreConditionalBranch
 */
export interface CoreConditionalBranch {
  /**
   *
   * @type {string}
   * @memberof CoreConditionalBranch
   */
  expression?: string
  /**
   *
   * @type {string}
   * @memberof CoreConditionalBranch
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CoreConditionalBranch
   */
  template?: string
}
/**
 *
 * @export
 * @interface CoreEvent
 */
export interface CoreEvent {
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  created_at?: string
  /**
   *
   * @type {number}
   * @memberof CoreEvent
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  object_id?: string
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  reason?: string
  /**
   *
   * @type {string}
   * @memberof CoreEvent
   */
  type?: string
}
/**
 *
 * @export
 * @interface CoreKubeObjectDesc
 */
export interface CoreKubeObjectDesc {
  /**
   *
   * @type {CoreKubeObjectMeta}
   * @memberof CoreKubeObjectDesc
   */
  metadata?: CoreKubeObjectMeta
  /**
   *
   * @type {object}
   * @memberof CoreKubeObjectDesc
   */
  spec?: object
}
/**
 *
 * @export
 * @interface CoreKubeObjectMeta
 */
export interface CoreKubeObjectMeta {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CoreKubeObjectMeta
   */
  annotations?: { [key: string]: string }
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CoreKubeObjectMeta
   */
  labels?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof CoreKubeObjectMeta
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CoreKubeObjectMeta
   */
  namespace?: string
}
/**
 *
 * @export
 * @interface CoreNode
 */
export interface CoreNode {
  /**
   *
   * @type {Array<CoreConditionalBranch>}
   * @memberof CoreNode
   */
  conditional_branches?: Array<CoreConditionalBranch>
  /**
   *
   * @type {string}
   * @memberof CoreNode
   */
  name?: string
  /**
   *
   * @type {Array<CoreNodeNameWithTemplate>}
   * @memberof CoreNode
   */
  parallel?: Array<CoreNodeNameWithTemplate>
  /**
   *
   * @type {Array<CoreNodeNameWithTemplate>}
   * @memberof CoreNode
   */
  serial?: Array<CoreNodeNameWithTemplate>
  /**
   *
   * @type {string}
   * @memberof CoreNode
   */
  state?: string
  /**
   *
   * @type {string}
   * @memberof CoreNode
   */
  template?: string
  /**
   *
   * @type {string}
   * @memberof CoreNode
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof CoreNode
   */
  uid?: string
}
/**
 *
 * @export
 * @interface CoreNodeNameWithTemplate
 */
export interface CoreNodeNameWithTemplate {
  /**
   *
   * @type {string}
   * @memberof CoreNodeNameWithTemplate
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CoreNodeNameWithTemplate
   */
  template?: string
}
/**
 *
 * @export
 * @interface CoreObjectBase
 */
export interface CoreObjectBase {
  /**
   *
   * @type {string}
   * @memberof CoreObjectBase
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof CoreObjectBase
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof CoreObjectBase
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CoreObjectBase
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof CoreObjectBase
   */
  uid?: string
}
/**
 *
 * @export
 * @interface CoreTopology
 */
export interface CoreTopology {
  /**
   *
   * @type {Array<CoreNode>}
   * @memberof CoreTopology
   */
  nodes?: Array<CoreNode>
}
/**
 *
 * @export
 * @interface CoreWorkflowDetail
 */
export interface CoreWorkflowDetail {
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  created_at?: string
  /**
   * EndTime represents the time when the workflow completed all steps.
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  end_time?: string
  /**
   * the entry node name
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  entry?: string
  /**
   * FinishTime represents the time when the workflow was deleted from Kubernetes.
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  finish_time?: string
  /**
   *
   * @type {number}
   * @memberof CoreWorkflowDetail
   */
  id?: number
  /**
   *
   * @type {CoreKubeObjectDesc}
   * @memberof CoreWorkflowDetail
   */
  kube_object?: CoreKubeObjectDesc
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  status?: string
  /**
   *
   * @type {CoreTopology}
   * @memberof CoreWorkflowDetail
   */
  topology?: CoreTopology
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowDetail
   */
  uid?: string
}
/**
 *
 * @export
 * @interface CoreWorkflowMeta
 */
export interface CoreWorkflowMeta {
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  created_at?: string
  /**
   * EndTime represents the time when the workflow completed all steps.
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  end_time?: string
  /**
   * the entry node name
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  entry?: string
  /**
   * FinishTime represents the time when the workflow was deleted from Kubernetes.
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  finish_time?: string
  /**
   *
   * @type {number}
   * @memberof CoreWorkflowMeta
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof CoreWorkflowMeta
   */
  uid?: string
}
/**
 *
 * @export
 * @interface CurlRequestForm
 */
export interface CurlRequestForm {
  /**
   *
   * @type {string}
   * @memberof CurlRequestForm
   */
  body?: string
  /**
   *
   * @type {boolean}
   * @memberof CurlRequestForm
   */
  followLocation?: boolean
  /**
   *
   * @type {{ [key: string]: Array<string>; }}
   * @memberof CurlRequestForm
   */
  header?: { [key: string]: Array<string> }
  /**
   *
   * @type {boolean}
   * @memberof CurlRequestForm
   */
  jsonContent?: boolean
  /**
   *
   * @type {string}
   * @memberof CurlRequestForm
   */
  method?: string
  /**
   *
   * @type {string}
   * @memberof CurlRequestForm
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CurlRequestForm
   */
  url?: string
}
/**
 *
 * @export
 * @interface ExperimentDetail
 */
export interface ExperimentDetail {
  /**
   *
   * @type {string}
   * @memberof ExperimentDetail
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentDetail
   */
  failed_message?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentDetail
   */
  kind?: string
  /**
   *
   * @type {CoreKubeObjectDesc}
   * @memberof ExperimentDetail
   */
  kube_object?: CoreKubeObjectDesc
  /**
   *
   * @type {string}
   * @memberof ExperimentDetail
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentDetail
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentDetail
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentDetail
   */
  uid?: string
}
/**
 *
 * @export
 * @interface ExperimentExperiment
 */
export interface ExperimentExperiment {
  /**
   *
   * @type {string}
   * @memberof ExperimentExperiment
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentExperiment
   */
  failed_message?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentExperiment
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentExperiment
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentExperiment
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentExperiment
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof ExperimentExperiment
   */
  uid?: string
}
/**
 *
 * @export
 * @interface ScheduleDetail
 */
export interface ScheduleDetail {
  /**
   *
   * @type {string}
   * @memberof ScheduleDetail
   */
  created_at?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ScheduleDetail
   */
  experiment_uids?: Array<string>
  /**
   *
   * @type {string}
   * @memberof ScheduleDetail
   */
  kind?: string
  /**
   *
   * @type {CoreKubeObjectDesc}
   * @memberof ScheduleDetail
   */
  kube_object?: CoreKubeObjectDesc
  /**
   *
   * @type {string}
   * @memberof ScheduleDetail
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleDetail
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleDetail
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleDetail
   */
  uid?: string
}
/**
 *
 * @export
 * @interface ScheduleSchedule
 */
export interface ScheduleSchedule {
  /**
   *
   * @type {string}
   * @memberof ScheduleSchedule
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleSchedule
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleSchedule
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleSchedule
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleSchedule
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof ScheduleSchedule
   */
  uid?: string
}
/**
 *
 * @export
 * @interface StatusAllChaosStatus
 */
export interface StatusAllChaosStatus {
  /**
   *
   * @type {number}
   * @memberof StatusAllChaosStatus
   */
  deleting?: number
  /**
   *
   * @type {number}
   * @memberof StatusAllChaosStatus
   */
  finished?: number
  /**
   *
   * @type {number}
   * @memberof StatusAllChaosStatus
   */
  injecting?: number
  /**
   *
   * @type {number}
   * @memberof StatusAllChaosStatus
   */
  paused?: number
  /**
   *
   * @type {number}
   * @memberof StatusAllChaosStatus
   */
  running?: number
}
/**
 *
 * @export
 * @interface TemplateStatusCheckTemplate
 */
export interface TemplateStatusCheckTemplate {
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplate
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplate
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplate
   */
  namespace?: string
  /**
   *
   * @type {V1alpha1StatusCheckTemplate}
   * @memberof TemplateStatusCheckTemplate
   */
  spec?: V1alpha1StatusCheckTemplate
}
/**
 *
 * @export
 * @interface TemplateStatusCheckTemplateBase
 */
export interface TemplateStatusCheckTemplateBase {
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateBase
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateBase
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateBase
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateBase
   */
  namespace?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateBase
   */
  uid?: string
}
/**
 *
 * @export
 * @interface TemplateStatusCheckTemplateDetail
 */
export interface TemplateStatusCheckTemplateDetail {
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateDetail
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateDetail
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateDetail
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateDetail
   */
  namespace?: string
  /**
   *
   * @type {V1alpha1StatusCheckTemplate}
   * @memberof TemplateStatusCheckTemplateDetail
   */
  spec?: V1alpha1StatusCheckTemplate
  /**
   *
   * @type {string}
   * @memberof TemplateStatusCheckTemplateDetail
   */
  uid?: string
}
/**
 *
 * @export
 * @interface UtilsAPIError
 */
export interface UtilsAPIError {
  /**
   *
   * @type {number}
   * @memberof UtilsAPIError
   */
  code?: number
  /**
   *
   * @type {string}
   * @memberof UtilsAPIError
   */
  full_text?: string
  /**
   *
   * @type {string}
   * @memberof UtilsAPIError
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof UtilsAPIError
   */
  type?: string
}
/**
 *
 * @export
 * @interface UtilsResponse
 */
export interface UtilsResponse {
  /**
   *
   * @type {string}
   * @memberof UtilsResponse
   */
  status?: string
}
/**
 *
 * @export
 * @interface V1alpha1AWSChaosSpec
 */
export interface V1alpha1AWSChaosSpec {
  /**
   * Action defines the specific aws chaos action. Supported action: ec2-stop / ec2-restart / detach-volume Default action: ec2-stop +kubebuilder:validation:Enum=ec2-stop;ec2-restart;detach-volume
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  action?: string
  /**
   * AWSRegion defines the region of aws.
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  awsRegion?: string
  /**
   * DeviceName indicates the name of the device. Needed in detach-volume. +ui:form:when=action==\'detach-volume\' +optional
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  deviceName?: string
  /**
   * Duration represents the duration of the chaos action. +optional
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  duration?: string
  /**
   * Ec2Instance indicates the ID of the ec2 instance.
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  ec2Instance?: string
  /**
   * Endpoint indicates the endpoint of the aws server. Just used it in test now. +ui:form:ignore +optional
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  endpoint?: string
  /**
   * SecretName defines the name of kubernetes secret. +optional
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  secretName?: string
  /**
   * EbsVolume indicates the ID of the EBS volume. Needed in detach-volume. +ui:form:when=action==\'detach-volume\' +optional
   * @type {string}
   * @memberof V1alpha1AWSChaosSpec
   */
  volumeID?: string
}
/**
 *
 * @export
 * @interface V1alpha1AttrOverrideSpec
 */
export interface V1alpha1AttrOverrideSpec {
  /**
   *
   * @type {V1alpha1Timespec}
   * @memberof V1alpha1AttrOverrideSpec
   */
  atime?: V1alpha1Timespec
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  blocks?: number
  /**
   *
   * @type {V1alpha1Timespec}
   * @memberof V1alpha1AttrOverrideSpec
   */
  ctime?: V1alpha1Timespec
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  gid?: number
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  ino?: number
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1AttrOverrideSpec
   */
  kind?: string
  /**
   *
   * @type {V1alpha1Timespec}
   * @memberof V1alpha1AttrOverrideSpec
   */
  mtime?: V1alpha1Timespec
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  nlink?: number
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  perm?: number
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  rdev?: number
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  size?: number
  /**
   * +optional
   * @type {number}
   * @memberof V1alpha1AttrOverrideSpec
   */
  uid?: number
}
/**
 *
 * @export
 * @interface V1alpha1AzureChaosSpec
 */
export interface V1alpha1AzureChaosSpec {
  /**
   * Action defines the specific azure chaos action. Supported action: vm-stop / vm-restart / disk-detach Default action: vm-stop +kubebuilder:validation:Enum=vm-stop;vm-restart;disk-detach
   * @type {string}
   * @memberof V1alpha1AzureChaosSpec
   */
  action?: string
  /**
   * DiskName indicates the name of the disk. Needed in disk-detach. +optional
   * @type {string}
   * @memberof V1alpha1AzureChaosSpec
   */
  diskName?: string
  /**
   * Duration represents the duration of the chaos action. +optional
   * @type {string}
   * @memberof V1alpha1AzureChaosSpec
   */
  duration?: string
  /**
   * LUN indicates the Logical Unit Number of the data disk. Needed in disk-detach. +optional
   * @type {number}
   * @memberof V1alpha1AzureChaosSpec
   */
  lun?: number
  /**
   * ResourceGroupName defines the name of ResourceGroup
   * @type {string}
   * @memberof V1alpha1AzureChaosSpec
   */
  resourceGroupName?: string
  /**
   * SecretName defines the name of kubernetes secret. It is used for Azure credentials. +optional
   * @type {string}
   * @memberof V1alpha1AzureChaosSpec
   */
  secretName?: string
  /**
   * SubscriptionID defines the id of Azure subscription.
   * @type {string}
   * @memberof V1alpha1AzureChaosSpec
   */
  subscriptionID?: string
  /**
   * VMName defines the name of Virtual Machine
   * @type {string}
   * @memberof V1alpha1AzureChaosSpec
   */
  vmName?: string
}
/**
 *
 * @export
 * @interface V1alpha1BandwidthSpec
 */
export interface V1alpha1BandwidthSpec {
  /**
   * Buffer is the maximum amount of bytes that tokens can be available for instantaneously. +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1BandwidthSpec
   */
  buffer?: number
  /**
   * Limit is the number of bytes that can be queued waiting for tokens to become available. +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1BandwidthSpec
   */
  limit?: number
  /**
   * Minburst specifies the size of the peakrate bucket. For perfect accuracy, should be set to the MTU of the interface.  If a peakrate is needed, but some burstiness is acceptable, this size can be raised. A 3000 byte minburst allows around 3mbit/s of peakrate, given 1000 byte packets. +optional +kubebuilder:validation:Minimum=0
   * @type {number}
   * @memberof V1alpha1BandwidthSpec
   */
  minburst?: number
  /**
   * Peakrate is the maximum depletion rate of the bucket. The peakrate does not need to be set, it is only necessary if perfect millisecond timescale shaping is required. +optional +kubebuilder:validation:Minimum=0
   * @type {number}
   * @memberof V1alpha1BandwidthSpec
   */
  peakrate?: number
  /**
   * Rate is the speed knob. Allows bps, kbps, mbps, gbps, tbps unit. bps means bytes per second.
   * @type {string}
   * @memberof V1alpha1BandwidthSpec
   */
  rate?: string
}
/**
 *
 * @export
 * @interface V1alpha1BlockChaosSpec
 */
export interface V1alpha1BlockChaosSpec {
  /**
   * Action defines the specific block chaos action. Supported action: limit / delay +kubebuilder:validation:Enum=limit;delay
   * @type {string}
   * @memberof V1alpha1BlockChaosSpec
   */
  action?: string
  /**
   * ContainerNames indicates list of the name of affected container. If not set, the first container will be injected +optional
   * @type {Array<string>}
   * @memberof V1alpha1BlockChaosSpec
   */
  containerNames?: Array<string>
  /**
   *
   * @type {V1alpha1BlockDelaySpec}
   * @memberof V1alpha1BlockChaosSpec
   */
  delay?: V1alpha1BlockDelaySpec
  /**
   * Duration represents the duration of the chaos action. +optional
   * @type {string}
   * @memberof V1alpha1BlockChaosSpec
   */
  duration?: string
  /**
   * IOPS defines the limit of IO frequency. +optional
   * @type {number}
   * @memberof V1alpha1BlockChaosSpec
   */
  iops?: number
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1BlockChaosSpec
   */
  mode?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1BlockChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1BlockChaosSpec
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1BlockChaosSpec
   */
  volumeName?: string
}
/**
 *
 * @export
 * @interface V1alpha1BlockDelaySpec
 */
export interface V1alpha1BlockDelaySpec {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1BlockDelaySpec
   */
  correlation?: string
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1BlockDelaySpec
   */
  jitter?: string
  /**
   * Latency defines the latency of every io request.
   * @type {string}
   * @memberof V1alpha1BlockDelaySpec
   */
  latency?: string
}
/**
 *
 * @export
 * @interface V1alpha1CPUStressor
 */
export interface V1alpha1CPUStressor {
  /**
   * Load specifies P percent loading per CPU worker. 0 is effectively a sleep (no load) and 100 is full loading. +kubebuilder:validation:Minimum=0 +kubebuilder:validation:Maximum=100 +optional
   * @type {number}
   * @memberof V1alpha1CPUStressor
   */
  load?: number
  /**
   * extend stress-ng options +optional
   * @type {Array<string>}
   * @memberof V1alpha1CPUStressor
   */
  options?: Array<string>
  /**
   * Workers specifies N workers to apply the stressor. Maximum 8192 workers can run by stress-ng +kubebuilder:validation:Maximum=8192
   * @type {number}
   * @memberof V1alpha1CPUStressor
   */
  workers?: number
}
/**
 *
 * @export
 * @interface V1alpha1ChaosOnlyScheduleSpec
 */
export interface V1alpha1ChaosOnlyScheduleSpec {
  /**
   *
   * @type {V1alpha1AWSChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  awsChaos?: V1alpha1AWSChaosSpec
  /**
   *
   * @type {V1alpha1AzureChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  azureChaos?: V1alpha1AzureChaosSpec
  /**
   *
   * @type {V1alpha1BlockChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  blockChaos?: V1alpha1BlockChaosSpec
  /**
   * +optional +kubebuilder:validation:Enum=Forbid;Allow
   * @type {string}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  concurrencyPolicy?: string
  /**
   *
   * @type {V1alpha1DNSChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  dnsChaos?: V1alpha1DNSChaosSpec
  /**
   *
   * @type {V1alpha1GCPChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  gcpChaos?: V1alpha1GCPChaosSpec
  /**
   * +optional +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  historyLimit?: number
  /**
   *
   * @type {V1alpha1HTTPChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  httpChaos?: V1alpha1HTTPChaosSpec
  /**
   *
   * @type {V1alpha1IOChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  ioChaos?: V1alpha1IOChaosSpec
  /**
   *
   * @type {V1alpha1JVMChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  jvmChaos?: V1alpha1JVMChaosSpec
  /**
   *
   * @type {V1alpha1KernelChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  kernelChaos?: V1alpha1KernelChaosSpec
  /**
   *
   * @type {V1alpha1NetworkChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  networkChaos?: V1alpha1NetworkChaosSpec
  /**
   *
   * @type {V1alpha1PhysicalMachineChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  physicalmachineChaos?: V1alpha1PhysicalMachineChaosSpec
  /**
   *
   * @type {V1alpha1PodChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  podChaos?: V1alpha1PodChaosSpec
  /**
   *
   * @type {string}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  schedule?: string
  /**
   * +optional +nullable +kubebuilder:validation:Minimum=0
   * @type {number}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  startingDeadlineSeconds?: number
  /**
   *
   * @type {V1alpha1StressChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  stressChaos?: V1alpha1StressChaosSpec
  /**
   *
   * @type {V1alpha1TimeChaosSpec}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  timeChaos?: V1alpha1TimeChaosSpec
  /**
   * TODO: use a custom type, as `TemplateType` contains other possible values
   * @type {string}
   * @memberof V1alpha1ChaosOnlyScheduleSpec
   */
  type?: string
}
/**
 *
 * @export
 * @interface V1alpha1ClockSpec
 */
export interface V1alpha1ClockSpec {
  /**
   * the identifier of the particular clock on which to act. More clock description in linux kernel can be found in man page of clock_getres, clock_gettime, clock_settime. Muti clock ids should be split with \",\"
   * @type {string}
   * @memberof V1alpha1ClockSpec
   */
  'clock-ids-slice'?: string
  /**
   * the pid of target program.
   * @type {number}
   * @memberof V1alpha1ClockSpec
   */
  pid?: number
  /**
   * specifies the length of time offset.
   * @type {string}
   * @memberof V1alpha1ClockSpec
   */
  'time-offset'?: string
}
/**
 *
 * @export
 * @interface V1alpha1ConditionalBranch
 */
export interface V1alpha1ConditionalBranch {
  /**
   * Expression is the expression for this conditional branch, expected type of result is boolean. If expression is empty, this branch will always be selected/the template will be spawned. +optional
   * @type {string}
   * @memberof V1alpha1ConditionalBranch
   */
  expression?: string
  /**
   * Target is the name of other template, if expression is evaluated as true, this template will be spawned.
   * @type {string}
   * @memberof V1alpha1ConditionalBranch
   */
  target?: string
}
/**
 *
 * @export
 * @interface V1alpha1CorruptSpec
 */
export interface V1alpha1CorruptSpec {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1CorruptSpec
   */
  correlation?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1CorruptSpec
   */
  corrupt?: string
}
/**
 *
 * @export
 * @interface V1alpha1DNSChaosSpec
 */
export interface V1alpha1DNSChaosSpec {
  /**
   * Action defines the specific DNS chaos action. Supported action: error, random Default action: error +kubebuilder:validation:Enum=error;random
   * @type {string}
   * @memberof V1alpha1DNSChaosSpec
   */
  action?: string
  /**
   * ContainerNames indicates list of the name of affected container. If not set, the first container will be injected +optional
   * @type {Array<string>}
   * @memberof V1alpha1DNSChaosSpec
   */
  containerNames?: Array<string>
  /**
   * Duration represents the duration of the chaos action
   * @type {string}
   * @memberof V1alpha1DNSChaosSpec
   */
  duration?: string
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1DNSChaosSpec
   */
  mode?: string
  /**
   * Choose which domain names to take effect, support the placeholder ? and wildcard *, or the Specified domain name. Note:      1. The wildcard * must be at the end of the string. For example, chaos-*.org is invalid.      2. if the patterns is empty, will take effect on all the domain names. For example:   The value is [\"google.com\", \"github.*\", \"chaos-mes?.org\"],   will take effect on \"google.com\", \"github.com\" and \"chaos-mesh.org\" +optional
   * @type {Array<string>}
   * @memberof V1alpha1DNSChaosSpec
   */
  patterns?: Array<string>
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1DNSChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1DNSChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1DelaySpec
 */
export interface V1alpha1DelaySpec {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1DelaySpec
   */
  correlation?: string
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1DelaySpec
   */
  jitter?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1DelaySpec
   */
  latency?: string
  /**
   *
   * @type {V1alpha1ReorderSpec}
   * @memberof V1alpha1DelaySpec
   */
  reorder?: V1alpha1ReorderSpec
}
/**
 *
 * @export
 * @interface V1alpha1DiskFillSpec
 */
export interface V1alpha1DiskFillSpec {
  /**
   * fill disk by fallocate
   * @type {boolean}
   * @memberof V1alpha1DiskFillSpec
   */
  'fill-by-fallocate'?: boolean
  /**
   * specifies the location to fill data in. if path not provided, payload will read/write from/into a temp file, temp file will be deleted after writing
   * @type {string}
   * @memberof V1alpha1DiskFillSpec
   */
  path?: string
  /**
   * specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
   * @type {string}
   * @memberof V1alpha1DiskFillSpec
   */
  size?: string
}
/**
 *
 * @export
 * @interface V1alpha1DiskPayloadSpec
 */
export interface V1alpha1DiskPayloadSpec {
  /**
   * specifies the location to fill data in. if path not provided, payload will read/write from/into a temp file, temp file will be deleted after writing
   * @type {string}
   * @memberof V1alpha1DiskPayloadSpec
   */
  path?: string
  /**
   * specifies the number of process work on writing, default 1, only 1-255 is valid value
   * @type {number}
   * @memberof V1alpha1DiskPayloadSpec
   */
  'payload-process-num'?: number
  /**
   * specifies how many units of data will write into the file path. support unit: c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, GB=1000*1000*1000, G=1024*1024*1024 BYTES. example : 1M | 512kB
   * @type {string}
   * @memberof V1alpha1DiskPayloadSpec
   */
  size?: string
}
/**
 *
 * @export
 * @interface V1alpha1DuplicateSpec
 */
export interface V1alpha1DuplicateSpec {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1DuplicateSpec
   */
  correlation?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1DuplicateSpec
   */
  duplicate?: string
}
/**
 *
 * @export
 * @interface V1alpha1FailKernRequest
 */
export interface V1alpha1FailKernRequest {
  /**
   * Callchain indicate a special call chain, such as:     ext4_mount       -> mount_subtree          -> ...             -> should_failslab With an optional set of predicates and an optional set of parameters, which used with predicates. You can read call chan and predicate examples from https://github.com/chaos-mesh/bpfki/tree/develop/examples to learn more. If no special call chain, just keep Callchain empty, which means it will fail at any call chain with slab alloc (eg: kmalloc).
   * @type {Array<V1alpha1Frame>}
   * @memberof V1alpha1FailKernRequest
   */
  callchain?: Array<V1alpha1Frame>
  /**
   * FailType indicates what to fail, can be set to \'0\' / \'1\' / \'2\' If `0`, indicates slab to fail (should_failslab) If `1`, indicates alloc_page to fail (should_fail_alloc_page) If `2`, indicates bio to fail (should_fail_bio) You can read:   1. https://www.kernel.org/doc/html/latest/fault-injection/fault-injection.html   2. http://github.com/iovisor/bcc/blob/master/tools/inject_example.txt to learn more +kubebuilder:validation:Maximum=2 +kubebuilder:validation:Minimum=0
   * @type {number}
   * @memberof V1alpha1FailKernRequest
   */
  failtype?: number
  /**
   * Headers indicates the appropriate kernel headers you need. Eg: \"linux/mmzone.h\", \"linux/blkdev.h\" and so on
   * @type {Array<string>}
   * @memberof V1alpha1FailKernRequest
   */
  headers?: Array<string>
  /**
   * Probability indicates the fails with probability. If you want 1%, please set this field with 1. +kubebuilder:validation:Minimum=0 +kubebuilder:validation:Maximum=100
   * @type {number}
   * @memberof V1alpha1FailKernRequest
   */
  probability?: number
  /**
   * Times indicates the max times of fails. +kubebuilder:validation:Minimum=0
   * @type {number}
   * @memberof V1alpha1FailKernRequest
   */
  times?: number
}
/**
 *
 * @export
 * @interface V1alpha1Frame
 */
export interface V1alpha1Frame {
  /**
   * Funcname can be find from kernel source or `/proc/kallsyms`, such as `ext4_mount`
   * @type {string}
   * @memberof V1alpha1Frame
   */
  funcname?: string
  /**
   * Parameters is used with predicate, for example, if you want to inject slab error in `d_alloc_parallel(struct dentry *parent, const struct qstr *name)` with a special name `bananas`, you need to set it to `struct dentry *parent, const struct qstr *name` otherwise omit it.
   * @type {string}
   * @memberof V1alpha1Frame
   */
  parameters?: string
  /**
   * Predicate will access the arguments of this Frame, example with Parameters\'s, you can set it to `STRNCMP(name->name, \"bananas\", 8)` to make inject only with it, or omit it to inject for all d_alloc_parallel call chain.
   * @type {string}
   * @memberof V1alpha1Frame
   */
  predicate?: string
}
/**
 *
 * @export
 * @interface V1alpha1GCPChaosSpec
 */
export interface V1alpha1GCPChaosSpec {
  /**
   * Action defines the specific gcp chaos action. Supported action: node-stop / node-reset / disk-loss Default action: node-stop +kubebuilder:validation:Enum=node-stop;node-reset;disk-loss
   * @type {string}
   * @memberof V1alpha1GCPChaosSpec
   */
  action?: string
  /**
   * The device name of disks to detach. Needed in disk-loss. +ui:form:when=action==\'disk-loss\' +optional
   * @type {Array<string>}
   * @memberof V1alpha1GCPChaosSpec
   */
  deviceNames?: Array<string>
  /**
   * Duration represents the duration of the chaos action. +optional
   * @type {string}
   * @memberof V1alpha1GCPChaosSpec
   */
  duration?: string
  /**
   * Instance defines the name of the instance
   * @type {string}
   * @memberof V1alpha1GCPChaosSpec
   */
  instance?: string
  /**
   * Project defines the ID of gcp project.
   * @type {string}
   * @memberof V1alpha1GCPChaosSpec
   */
  project?: string
  /**
   * SecretName defines the name of kubernetes secret. It is used for GCP credentials. +optional
   * @type {string}
   * @memberof V1alpha1GCPChaosSpec
   */
  secretName?: string
  /**
   * Zone defines the zone of gcp project.
   * @type {string}
   * @memberof V1alpha1GCPChaosSpec
   */
  zone?: string
}
/**
 *
 * @export
 * @interface V1alpha1HTTPChaosSpec
 */
export interface V1alpha1HTTPChaosSpec {
  /**
   * Abort is a rule to abort a http session. +optional
   * @type {boolean}
   * @memberof V1alpha1HTTPChaosSpec
   */
  abort?: boolean
  /**
   * Code is a rule to select target by http status code in response. +optional
   * @type {number}
   * @memberof V1alpha1HTTPChaosSpec
   */
  code?: number
  /**
   * Delay represents the delay of the target request/response. A duration string is a possibly unsigned sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". +optional
   * @type {string}
   * @memberof V1alpha1HTTPChaosSpec
   */
  delay?: string
  /**
   * Duration represents the duration of the chaos action. +optional
   * @type {string}
   * @memberof V1alpha1HTTPChaosSpec
   */
  duration?: string
  /**
   * Method is a rule to select target by http method in request. +optional
   * @type {string}
   * @memberof V1alpha1HTTPChaosSpec
   */
  method?: string
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1HTTPChaosSpec
   */
  mode?: string
  /**
   * Patch is a rule to patch some contents in target. +optional
   * @type {V1alpha1PodHttpChaosPatchActions}
   * @memberof V1alpha1HTTPChaosSpec
   */
  patch?: V1alpha1PodHttpChaosPatchActions
  /**
   * Path is a rule to select target by uri path in http request. +optional
   * @type {string}
   * @memberof V1alpha1HTTPChaosSpec
   */
  path?: string
  /**
   * Port represents the target port to be proxy of.
   * @type {number}
   * @memberof V1alpha1HTTPChaosSpec
   */
  port?: number
  /**
   * Replace is a rule to replace some contents in target. +optional
   * @type {V1alpha1PodHttpChaosReplaceActions}
   * @memberof V1alpha1HTTPChaosSpec
   */
  replace?: V1alpha1PodHttpChaosReplaceActions
  /**
   * RequestHeaders is a rule to select target by http headers in request. The key-value pairs represent header name and header value pairs. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1HTTPChaosSpec
   */
  request_headers?: { [key: string]: string }
  /**
   * ResponseHeaders is a rule to select target by http headers in response. The key-value pairs represent header name and header value pairs. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1HTTPChaosSpec
   */
  response_headers?: { [key: string]: string }
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1HTTPChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * Target is the object to be selected and injected. +kubebuilder:validation:Enum=Request;Response
   * @type {string}
   * @memberof V1alpha1HTTPChaosSpec
   */
  target?: string
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1HTTPChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1HTTPCriteria
 */
export interface V1alpha1HTTPCriteria {
  /**
   * StatusCode defines the expected http status code for the request. A statusCode string could be a single code (e.g. 200), or an inclusive range (e.g. 200-400, both `200` and `400` are included).
   * @type {string}
   * @memberof V1alpha1HTTPCriteria
   */
  statusCode?: string
}
/**
 *
 * @export
 * @interface V1alpha1HTTPStatusCheck
 */
export interface V1alpha1HTTPStatusCheck {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1HTTPStatusCheck
   */
  body?: string
  /**
   *
   * @type {V1alpha1HTTPCriteria}
   * @memberof V1alpha1HTTPStatusCheck
   */
  criteria?: V1alpha1HTTPCriteria
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1HTTPStatusCheck
   */
  headers?: string
  /**
   * +optional +kubebuilder:validation:Enum=GET;POST +kubebuilder:default=GET
   * @type {string}
   * @memberof V1alpha1HTTPStatusCheck
   */
  method?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1HTTPStatusCheck
   */
  url?: string
}
/**
 *
 * @export
 * @interface V1alpha1IOChaosSpec
 */
export interface V1alpha1IOChaosSpec {
  /**
   * Action defines the specific pod chaos action. Supported action: latency / fault / attrOverride / mistake +kubebuilder:validation:Enum=latency;fault;attrOverride;mistake
   * @type {string}
   * @memberof V1alpha1IOChaosSpec
   */
  action?: string
  /**
   * Attr defines the overrided attribution +ui:form:when=action==\'attrOverride\' +optional
   * @type {V1alpha1AttrOverrideSpec}
   * @memberof V1alpha1IOChaosSpec
   */
  attr?: V1alpha1AttrOverrideSpec
  /**
   * ContainerNames indicates list of the name of affected container. If not set, the first container will be injected +optional
   * @type {Array<string>}
   * @memberof V1alpha1IOChaosSpec
   */
  containerNames?: Array<string>
  /**
   * Delay defines the value of I/O chaos action delay. A delay string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". +ui:form:when=action==\'latency\' +optional
   * @type {string}
   * @memberof V1alpha1IOChaosSpec
   */
  delay?: string
  /**
   * Duration represents the duration of the chaos action. It is required when the action is `PodFailureAction`. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". +optional
   * @type {string}
   * @memberof V1alpha1IOChaosSpec
   */
  duration?: string
  /**
   * Errno defines the error code that returned by I/O action. refer to: https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html +ui:form:when=action==\'fault\' +optional
   * @type {number}
   * @memberof V1alpha1IOChaosSpec
   */
  errno?: number
  /**
   * Methods defines the I/O methods for injecting I/O chaos action. default: all I/O methods. +optional
   * @type {Array<string>}
   * @memberof V1alpha1IOChaosSpec
   */
  methods?: Array<string>
  /**
   * Mistake defines what types of incorrectness are injected to IO operations +ui:form:when=action==\'mistake\' +optional
   * @type {V1alpha1MistakeSpec}
   * @memberof V1alpha1IOChaosSpec
   */
  mistake?: V1alpha1MistakeSpec
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1IOChaosSpec
   */
  mode?: string
  /**
   * Path defines the path of files for injecting I/O chaos action. +optional
   * @type {string}
   * @memberof V1alpha1IOChaosSpec
   */
  path?: string
  /**
   * Percent defines the percentage of injection errors and provides a number from 0-100. default: 100. +optional +kubebuilder:default=100
   * @type {number}
   * @memberof V1alpha1IOChaosSpec
   */
  percent?: number
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1IOChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1IOChaosSpec
   */
  value?: string
  /**
   * VolumePath represents the mount path of injected volume
   * @type {string}
   * @memberof V1alpha1IOChaosSpec
   */
  volumePath?: string
}
/**
 *
 * @export
 * @interface V1alpha1JVMChaosSpec
 */
export interface V1alpha1JVMChaosSpec {
  /**
   * Action defines the specific jvm chaos action. Supported action: latency;return;exception;stress;gc;ruleData +kubebuilder:validation:Enum=latency;return;exception;stress;gc;ruleData
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  action?: string
  /**
   * +optional Java class
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  class?: string
  /**
   * ContainerNames indicates list of the name of affected container. If not set, the first container will be injected +optional
   * @type {Array<string>}
   * @memberof V1alpha1JVMChaosSpec
   */
  containerNames?: Array<string>
  /**
   * +optional the CPU core number needs to use, only set it when action is stress
   * @type {number}
   * @memberof V1alpha1JVMChaosSpec
   */
  cpuCount?: number
  /**
   * Duration represents the duration of the chaos action +optional
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  duration?: string
  /**
   * +optional the exception which needs to throw for action `exception`
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  exception?: string
  /**
   * +optional the latency duration for action \'latency\', unit ms
   * @type {number}
   * @memberof V1alpha1JVMChaosSpec
   */
  latency?: number
  /**
   * +optional the memory type needs to locate, only set it when action is stress, the value can be \'stack\' or \'heap\'
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  memType?: string
  /**
   * +optional the method in Java class
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  method?: string
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  mode?: string
  /**
   * +optional byteman rule name, should be unique, and will use JVMChaos\' name if not set
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  name?: string
  /**
   * the pid of Java process which needs to attach
   * @type {number}
   * @memberof V1alpha1JVMChaosSpec
   */
  pid?: number
  /**
   * +optional the port of agent server, default 9277
   * @type {number}
   * @memberof V1alpha1JVMChaosSpec
   */
  port?: number
  /**
   * +optional the byteman rule\'s data for action \'ruleData\'
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  ruleData?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1JVMChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * +optional the return value for action \'return\'
   * @type {string}
   * @memberof V1alpha1JVMChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1JVMExceptionSpec
 */
export interface V1alpha1JVMExceptionSpec {
  /**
   * +optional Java class
   * @type {string}
   * @memberof V1alpha1JVMExceptionSpec
   */
  class?: string
  /**
   * the exception which needs to throw for action `exception`
   * @type {string}
   * @memberof V1alpha1JVMExceptionSpec
   */
  exception?: string
  /**
   * +optional the method in Java class
   * @type {string}
   * @memberof V1alpha1JVMExceptionSpec
   */
  method?: string
  /**
   * the pid of Java process which needs to attach
   * @type {number}
   * @memberof V1alpha1JVMExceptionSpec
   */
  pid?: number
  /**
   * +optional the port of agent server, default 9277
   * @type {number}
   * @memberof V1alpha1JVMExceptionSpec
   */
  port?: number
}
/**
 *
 * @export
 * @interface V1alpha1JVMGCSpec
 */
export interface V1alpha1JVMGCSpec {
  /**
   * the pid of Java process which needs to attach
   * @type {number}
   * @memberof V1alpha1JVMGCSpec
   */
  pid?: number
  /**
   * +optional the port of agent server, default 9277
   * @type {number}
   * @memberof V1alpha1JVMGCSpec
   */
  port?: number
}
/**
 *
 * @export
 * @interface V1alpha1JVMLatencySpec
 */
export interface V1alpha1JVMLatencySpec {
  /**
   * +optional Java class
   * @type {string}
   * @memberof V1alpha1JVMLatencySpec
   */
  class?: string
  /**
   * the latency duration for action \'latency\', unit ms
   * @type {number}
   * @memberof V1alpha1JVMLatencySpec
   */
  latency?: number
  /**
   * +optional the method in Java class
   * @type {string}
   * @memberof V1alpha1JVMLatencySpec
   */
  method?: string
  /**
   * the pid of Java process which needs to attach
   * @type {number}
   * @memberof V1alpha1JVMLatencySpec
   */
  pid?: number
  /**
   * +optional the port of agent server, default 9277
   * @type {number}
   * @memberof V1alpha1JVMLatencySpec
   */
  port?: number
}
/**
 *
 * @export
 * @interface V1alpha1JVMReturnSpec
 */
export interface V1alpha1JVMReturnSpec {
  /**
   * +optional Java class
   * @type {string}
   * @memberof V1alpha1JVMReturnSpec
   */
  class?: string
  /**
   * +optional the method in Java class
   * @type {string}
   * @memberof V1alpha1JVMReturnSpec
   */
  method?: string
  /**
   * the pid of Java process which needs to attach
   * @type {number}
   * @memberof V1alpha1JVMReturnSpec
   */
  pid?: number
  /**
   * +optional the port of agent server, default 9277
   * @type {number}
   * @memberof V1alpha1JVMReturnSpec
   */
  port?: number
  /**
   * the return value for action \'return\'
   * @type {string}
   * @memberof V1alpha1JVMReturnSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1JVMRuleDataSpec
 */
export interface V1alpha1JVMRuleDataSpec {
  /**
   * the pid of Java process which needs to attach
   * @type {number}
   * @memberof V1alpha1JVMRuleDataSpec
   */
  pid?: number
  /**
   * +optional the port of agent server, default 9277
   * @type {number}
   * @memberof V1alpha1JVMRuleDataSpec
   */
  port?: number
  /**
   * RuleData used to save the rule file\'s data, will use it when recover
   * @type {string}
   * @memberof V1alpha1JVMRuleDataSpec
   */
  'rule-data'?: string
}
/**
 *
 * @export
 * @interface V1alpha1JVMStressSpec
 */
export interface V1alpha1JVMStressSpec {
  /**
   * the CPU core number need to use, only set it when action is stress
   * @type {number}
   * @memberof V1alpha1JVMStressSpec
   */
  'cpu-count'?: number
  /**
   * the memory type need to locate, only set it when action is stress, the value can be \'stack\' or \'heap\'
   * @type {string}
   * @memberof V1alpha1JVMStressSpec
   */
  'mem-type'?: string
  /**
   * the pid of Java process which needs to attach
   * @type {number}
   * @memberof V1alpha1JVMStressSpec
   */
  pid?: number
  /**
   * +optional the port of agent server, default 9277
   * @type {number}
   * @memberof V1alpha1JVMStressSpec
   */
  port?: number
}
/**
 *
 * @export
 * @interface V1alpha1KernelChaosSpec
 */
export interface V1alpha1KernelChaosSpec {
  /**
   * Duration represents the duration of the chaos action
   * @type {string}
   * @memberof V1alpha1KernelChaosSpec
   */
  duration?: string
  /**
   *
   * @type {V1alpha1FailKernRequest}
   * @memberof V1alpha1KernelChaosSpec
   */
  failKernRequest?: V1alpha1FailKernRequest
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1KernelChaosSpec
   */
  mode?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1KernelChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1KernelChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1LossSpec
 */
export interface V1alpha1LossSpec {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1LossSpec
   */
  correlation?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1LossSpec
   */
  loss?: string
}
/**
 *
 * @export
 * @interface V1alpha1MemoryStressor
 */
export interface V1alpha1MemoryStressor {
  /**
   * OOMScoreAdj sets the oom_score_adj of the stress process. See `man 5 proc` to know more about this option. +kubebuilder:validation:Minimum=-1000 +kubebuilder:validation:Maximum=1000 +kubebuilder:default=0 +optional
   * @type {number}
   * @memberof V1alpha1MemoryStressor
   */
  oomScoreAdj?: number
  /**
   * extend stress-ng options +optional
   * @type {Array<string>}
   * @memberof V1alpha1MemoryStressor
   */
  options?: Array<string>
  /**
   * Size specifies N bytes consumed per vm worker, default is the total available memory. One can specify the size as % of total available memory or in units of B, KB/KiB, MB/MiB, GB/GiB, TB/TiB. +optional
   * @type {string}
   * @memberof V1alpha1MemoryStressor
   */
  size?: string
  /**
   * Workers specifies N workers to apply the stressor. Maximum 8192 workers can run by stress-ng +kubebuilder:validation:Maximum=8192
   * @type {number}
   * @memberof V1alpha1MemoryStressor
   */
  workers?: number
}
/**
 *
 * @export
 * @interface V1alpha1MistakeSpec
 */
export interface V1alpha1MistakeSpec {
  /**
   * Filling determines what is filled in the mistake data. +optional +kubebuilder:validation:Enum=zero;random
   * @type {string}
   * @memberof V1alpha1MistakeSpec
   */
  filling?: string
  /**
   * Max length of each wrong data segment in bytes +optional +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1MistakeSpec
   */
  maxLength?: number
  /**
   * There will be [1, MaxOccurrences] segments of wrong data. +optional +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1MistakeSpec
   */
  maxOccurrences?: number
}
/**
 *
 * @export
 * @interface V1alpha1NetworkBandwidthSpec
 */
export interface V1alpha1NetworkBandwidthSpec {
  /**
   * +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  buffer?: number
  /**
   *
   * @type {string}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  device?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  hostname?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  'ip-address'?: string
  /**
   * +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  minburst?: number
  /**
   *
   * @type {number}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  peakrate?: number
  /**
   *
   * @type {string}
   * @memberof V1alpha1NetworkBandwidthSpec
   */
  rate?: string
}
/**
 *
 * @export
 * @interface V1alpha1NetworkChaosSpec
 */
export interface V1alpha1NetworkChaosSpec {
  /**
   * Action defines the specific network chaos action. Supported action: partition, netem, delay, loss, duplicate, corrupt Default action: delay +kubebuilder:validation:Enum=netem;delay;loss;duplicate;corrupt;partition;bandwidth
   * @type {string}
   * @memberof V1alpha1NetworkChaosSpec
   */
  action?: string
  /**
   * Bandwidth represents the detail about bandwidth control action +ui:form:when=action==\'bandwidth\' +optional
   * @type {V1alpha1BandwidthSpec}
   * @memberof V1alpha1NetworkChaosSpec
   */
  bandwidth?: V1alpha1BandwidthSpec
  /**
   * Corrupt represents the detail about corrupt action +ui:form:when=action==\'corrupt\' +optional
   * @type {V1alpha1CorruptSpec}
   * @memberof V1alpha1NetworkChaosSpec
   */
  corrupt?: V1alpha1CorruptSpec
  /**
   * Delay represents the detail about delay action +ui:form:when=action==\'delay\' +optional
   * @type {V1alpha1DelaySpec}
   * @memberof V1alpha1NetworkChaosSpec
   */
  delay?: V1alpha1DelaySpec
  /**
   * Device represents the network device to be affected. +optional
   * @type {string}
   * @memberof V1alpha1NetworkChaosSpec
   */
  device?: string
  /**
   * Direction represents the direction, this applies on netem and network partition action +optional +kubebuilder:validation:Enum=to;from;both +kubebuilder:default=to
   * @type {string}
   * @memberof V1alpha1NetworkChaosSpec
   */
  direction?: string
  /**
   * DuplicateSpec represents the detail about loss action +ui:form:when=action==\'duplicate\' +optional
   * @type {V1alpha1DuplicateSpec}
   * @memberof V1alpha1NetworkChaosSpec
   */
  duplicate?: V1alpha1DuplicateSpec
  /**
   * Duration represents the duration of the chaos action
   * @type {string}
   * @memberof V1alpha1NetworkChaosSpec
   */
  duration?: string
  /**
   * ExternalTargets represents network targets outside k8s +optional
   * @type {Array<string>}
   * @memberof V1alpha1NetworkChaosSpec
   */
  externalTargets?: Array<string>
  /**
   * Loss represents the detail about loss action +ui:form:when=action==\'loss\' +optional
   * @type {V1alpha1LossSpec}
   * @memberof V1alpha1NetworkChaosSpec
   */
  loss?: V1alpha1LossSpec
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1NetworkChaosSpec
   */
  mode?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1NetworkChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   *
   * @type {V1alpha1PodSelector}
   * @memberof V1alpha1NetworkChaosSpec
   */
  target?: V1alpha1PodSelector
  /**
   * TargetDevice represents the network device to be affected in target scope. +optional
   * @type {string}
   * @memberof V1alpha1NetworkChaosSpec
   */
  targetDevice?: string
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1NetworkChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1NetworkCorruptSpec
 */
export interface V1alpha1NetworkCorruptSpec {
  /**
   * correlation is percentage (10 is 10%)
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  correlation?: string
  /**
   * the network interface to impact
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  device?: string
  /**
   * only impact egress traffic to these destination ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  'egress-port'?: string
  /**
   * only impact traffic to these hostnames
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  hostname?: string
  /**
   * only impact egress traffic to these IP addresses
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  'ip-address'?: string
  /**
   * only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  'ip-protocol'?: string
  /**
   * percentage of packets to corrupt (10 is 10%)
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  percent?: string
  /**
   * only impact egress traffic from these source ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkCorruptSpec
   */
  'source-port'?: string
}
/**
 *
 * @export
 * @interface V1alpha1NetworkDNSSpec
 */
export interface V1alpha1NetworkDNSSpec {
  /**
   * map this host to specified IP
   * @type {string}
   * @memberof V1alpha1NetworkDNSSpec
   */
  'dns-domain-name'?: string
  /**
   * map specified host to this IP address
   * @type {string}
   * @memberof V1alpha1NetworkDNSSpec
   */
  'dns-ip'?: string
  /**
   * update the DNS server in /etc/resolv.conf with this value
   * @type {string}
   * @memberof V1alpha1NetworkDNSSpec
   */
  'dns-server'?: string
}
/**
 *
 * @export
 * @interface V1alpha1NetworkDelaySpec
 */
export interface V1alpha1NetworkDelaySpec {
  /**
   * correlation is percentage (10 is 10%)
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  correlation?: string
  /**
   * the network interface to impact
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  device?: string
  /**
   * only impact egress traffic to these destination ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  'egress-port'?: string
  /**
   * only impact traffic to these hostnames
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  hostname?: string
  /**
   * only impact egress traffic to these IP addresses
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  'ip-address'?: string
  /**
   * only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  'ip-protocol'?: string
  /**
   * jitter time, time units: ns, us (or µs), ms, s, m, h.
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  jitter?: string
  /**
   * delay egress time, time units: ns, us (or µs), ms, s, m, h.
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  latency?: string
  /**
   * only impact egress traffic from these source ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkDelaySpec
   */
  'source-port'?: string
}
/**
 *
 * @export
 * @interface V1alpha1NetworkDuplicateSpec
 */
export interface V1alpha1NetworkDuplicateSpec {
  /**
   * correlation is percentage (10 is 10%)
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  correlation?: string
  /**
   * the network interface to impact
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  device?: string
  /**
   * only impact egress traffic to these destination ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  'egress-port'?: string
  /**
   * only impact traffic to these hostnames
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  hostname?: string
  /**
   * only impact egress traffic to these IP addresses
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  'ip-address'?: string
  /**
   * only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  'ip-protocol'?: string
  /**
   * percentage of packets to duplicate (10 is 10%)
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  percent?: string
  /**
   * only impact egress traffic from these source ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkDuplicateSpec
   */
  'source-port'?: string
}
/**
 *
 * @export
 * @interface V1alpha1NetworkLossSpec
 */
export interface V1alpha1NetworkLossSpec {
  /**
   * correlation is percentage (10 is 10%)
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  correlation?: string
  /**
   * the network interface to impact
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  device?: string
  /**
   * only impact egress traffic to these destination ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  'egress-port'?: string
  /**
   * only impact traffic to these hostnames
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  hostname?: string
  /**
   * only impact egress traffic to these IP addresses
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  'ip-address'?: string
  /**
   * only impact traffic using this IP protocol, supported: tcp, udp, icmp, all
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  'ip-protocol'?: string
  /**
   * percentage of packets to loss (10 is 10%)
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  percent?: string
  /**
   * only impact egress traffic from these source ports, use a \',\' to separate or to indicate the range, such as 80, 8001:8010. it can only be used in conjunction with -p tcp or -p udp
   * @type {string}
   * @memberof V1alpha1NetworkLossSpec
   */
  'source-port'?: string
}
/**
 *
 * @export
 * @interface V1alpha1NetworkPartitionSpec
 */
export interface V1alpha1NetworkPartitionSpec {
  /**
   * only the packet which match the tcp flag can be accepted, others will be dropped. only set when the IPProtocol is tcp, used for partition.
   * @type {string}
   * @memberof V1alpha1NetworkPartitionSpec
   */
  'accept-tcp-flags'?: string
  /**
   * the network interface to impact
   * @type {string}
   * @memberof V1alpha1NetworkPartitionSpec
   */
  device?: string
  /**
   * specifies the partition direction, values can be \'from\', \'to\'. \'from\' means packets coming from the \'IPAddress\' or \'Hostname\' and going to your server, \'to\' means packets originating from your server and going to the \'IPAddress\' or \'Hostname\'.
   * @type {string}
   * @memberof V1alpha1NetworkPartitionSpec
   */
  direction?: string
  /**
   * only impact traffic to these hostnames
   * @type {string}
   * @memberof V1alpha1NetworkPartitionSpec
   */
  hostname?: string
  /**
   * only impact egress traffic to these IP addresses
   * @type {string}
   * @memberof V1alpha1NetworkPartitionSpec
   */
  'ip-address'?: string
  /**
   * only impact egress traffic to these IP addresses
   * @type {string}
   * @memberof V1alpha1NetworkPartitionSpec
   */
  'ip-protocol'?: string
}
/**
 *
 * @export
 * @interface V1alpha1PhysicalMachineChaosSpec
 */
export interface V1alpha1PhysicalMachineChaosSpec {
  /**
   * +kubebuilder:validation:Enum=stress-cpu;stress-mem;disk-read-payload;disk-write-payload;disk-fill;network-corrupt;network-duplicate;network-loss;network-delay;network-partition;network-dns;network-bandwidth;process;jvm-exception;jvm-gc;jvm-latency;jvm-return;jvm-stress;jvm-rule-data;clock
   * @type {string}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  action?: string
  /**
   * DEPRECATED: Use Selector instead. Only one of Address and Selector could be specified. +optional
   * @type {Array<string>}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  address?: Array<string>
  /**
   * +ui:form:when=action==\'clock\' +optional
   * @type {V1alpha1ClockSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  clock?: V1alpha1ClockSpec
  /**
   * +ui:form:when=action==\'disk-fill\' +optional
   * @type {V1alpha1DiskFillSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'disk-fill'?: V1alpha1DiskFillSpec
  /**
   * +ui:form:when=action==\'disk-read-payload\' +optional
   * @type {V1alpha1DiskPayloadSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'disk-read-payload'?: V1alpha1DiskPayloadSpec
  /**
   * +ui:form:when=action==\'disk-write-payload\' +optional
   * @type {V1alpha1DiskPayloadSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'disk-write-payload'?: V1alpha1DiskPayloadSpec
  /**
   * Duration represents the duration of the chaos action +optional
   * @type {string}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  duration?: string
  /**
   * +ui:form:when=action==\'jvm-exception\' +optional
   * @type {V1alpha1JVMExceptionSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'jvm-exception'?: V1alpha1JVMExceptionSpec
  /**
   * +ui:form:when=action==\'jvm-gc\' +optional
   * @type {V1alpha1JVMGCSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'jvm-gc'?: V1alpha1JVMGCSpec
  /**
   * +ui:form:when=action==\'jvm-latency\' +optional
   * @type {V1alpha1JVMLatencySpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'jvm-latency'?: V1alpha1JVMLatencySpec
  /**
   * +ui:form:when=action==\'jvm-return\' +optional
   * @type {V1alpha1JVMReturnSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'jvm-return'?: V1alpha1JVMReturnSpec
  /**
   * +ui:form:when=action==\'jvm-rule-data\' +optional
   * @type {V1alpha1JVMRuleDataSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'jvm-rule-data'?: V1alpha1JVMRuleDataSpec
  /**
   * +ui:form:when=action==\'jvm-stress\' +optional
   * @type {V1alpha1JVMStressSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'jvm-stress'?: V1alpha1JVMStressSpec
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  mode?: string
  /**
   * +ui:form:when=action==\'network-bandwidth\' +optional
   * @type {V1alpha1NetworkBandwidthSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'network-bandwidth'?: V1alpha1NetworkBandwidthSpec
  /**
   * +ui:form:when=action==\'network-corrupt\' +optional
   * @type {V1alpha1NetworkCorruptSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'network-corrupt'?: V1alpha1NetworkCorruptSpec
  /**
   * +ui:form:when=action==\'network-delay\' +optional
   * @type {V1alpha1NetworkDelaySpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'network-delay'?: V1alpha1NetworkDelaySpec
  /**
   * +ui:form:when=action==\'network-dns\' +optional
   * @type {V1alpha1NetworkDNSSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'network-dns'?: V1alpha1NetworkDNSSpec
  /**
   * +ui:form:when=action==\'network-duplicate\' +optional
   * @type {V1alpha1NetworkDuplicateSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'network-duplicate'?: V1alpha1NetworkDuplicateSpec
  /**
   * +ui:form:when=action==\'network-loss\' +optional
   * @type {V1alpha1NetworkLossSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'network-loss'?: V1alpha1NetworkLossSpec
  /**
   * +ui:form:when=action==\'network-partition\' +optional
   * @type {V1alpha1NetworkPartitionSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'network-partition'?: V1alpha1NetworkPartitionSpec
  /**
   * +ui:form:when=action==\'process\' +optional
   * @type {V1alpha1ProcessSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  process?: V1alpha1ProcessSpec
  /**
   *
   * @type {V1alpha1PhysicalMachineSelectorSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  selector?: V1alpha1PhysicalMachineSelectorSpec
  /**
   * +ui:form:when=action==\'stress-cpu\' +optional
   * @type {V1alpha1StressCPUSpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'stress-cpu'?: V1alpha1StressCPUSpec
  /**
   * +ui:form:when=action==\'stress-mem\' +optional
   * @type {V1alpha1StressMemorySpec}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  'stress-mem'?: V1alpha1StressMemorySpec
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of physical machines to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of physical machines the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1PhysicalMachineChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1PhysicalMachineSelectorSpec
 */
export interface V1alpha1PhysicalMachineSelectorSpec {
  /**
   * Map of string keys and values that can be used to select objects. A selector based on annotations. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PhysicalMachineSelectorSpec
   */
  annotationSelectors?: { [key: string]: string }
  /**
   * Map of string keys and values that can be used to select objects. A selector based on fields. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PhysicalMachineSelectorSpec
   */
  fieldSelectors?: { [key: string]: string }
  /**
   * Map of string keys and values that can be used to select objects. A selector based on labels. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PhysicalMachineSelectorSpec
   */
  labelSelectors?: { [key: string]: string }
  /**
   * Namespaces is a set of namespace to which objects belong. +optional
   * @type {Array<string>}
   * @memberof V1alpha1PhysicalMachineSelectorSpec
   */
  namespaces?: Array<string>
  /**
   * PhysicalMachines is a map of string keys and a set values that used to select physical machines. The key defines the namespace which physical machine belong, and each value is a set of physical machine names. +optional
   * @type {{ [key: string]: Array<string>; }}
   * @memberof V1alpha1PhysicalMachineSelectorSpec
   */
  physicalMachines?: { [key: string]: Array<string> }
}
/**
 *
 * @export
 * @interface V1alpha1PodChaosSpec
 */
export interface V1alpha1PodChaosSpec {
  /**
   * Action defines the specific pod chaos action. Supported action: pod-kill / pod-failure / container-kill Default action: pod-kill +kubebuilder:validation:Enum=pod-kill;pod-failure;container-kill
   * @type {string}
   * @memberof V1alpha1PodChaosSpec
   */
  action?: string
  /**
   * ContainerNames indicates list of the name of affected container. If not set, the first container will be injected +optional
   * @type {Array<string>}
   * @memberof V1alpha1PodChaosSpec
   */
  containerNames?: Array<string>
  /**
   * Duration represents the duration of the chaos action. It is required when the action is `PodFailureAction`. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". +optional
   * @type {string}
   * @memberof V1alpha1PodChaosSpec
   */
  duration?: string
  /**
   * GracePeriod is used in pod-kill action. It represents the duration in seconds before the pod should be deleted. Value must be non-negative integer. The default value is zero that indicates delete immediately. +optional +kubebuilder:validation:Minimum=0
   * @type {number}
   * @memberof V1alpha1PodChaosSpec
   */
  gracePeriod?: number
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1PodChaosSpec
   */
  mode?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1PodChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1PodChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1PodHttpChaosPatchActions
 */
export interface V1alpha1PodHttpChaosPatchActions {
  /**
   * Body is a rule to patch message body of target. +optional
   * @type {V1alpha1PodHttpChaosPatchBodyAction}
   * @memberof V1alpha1PodHttpChaosPatchActions
   */
  body?: V1alpha1PodHttpChaosPatchBodyAction
  /**
   * Headers is a rule to append http headers of target. For example: `[[\"Set-Cookie\", \"<one cookie>\"], [\"Set-Cookie\", \"<another cookie>\"]]`. +optional
   * @type {Array<Array<string>>}
   * @memberof V1alpha1PodHttpChaosPatchActions
   */
  headers?: Array<Array<string>>
  /**
   * Queries is a rule to append uri queries of target(Request only). For example: `[[\"foo\", \"bar\"], [\"foo\", \"unknown\"]]`. +optional
   * @type {Array<Array<string>>}
   * @memberof V1alpha1PodHttpChaosPatchActions
   */
  queries?: Array<Array<string>>
}
/**
 *
 * @export
 * @interface V1alpha1PodHttpChaosPatchBodyAction
 */
export interface V1alpha1PodHttpChaosPatchBodyAction {
  /**
   * Type represents the patch type, only support `JSON` as [merge patch json](https://tools.ietf.org/html/rfc7396) currently.
   * @type {string}
   * @memberof V1alpha1PodHttpChaosPatchBodyAction
   */
  type?: string
  /**
   * Value is the patch contents.
   * @type {string}
   * @memberof V1alpha1PodHttpChaosPatchBodyAction
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1PodHttpChaosReplaceActions
 */
export interface V1alpha1PodHttpChaosReplaceActions {
  /**
   * Body is a rule to replace http message body in target. +optional
   * @type {Array<number>}
   * @memberof V1alpha1PodHttpChaosReplaceActions
   */
  body?: Array<number>
  /**
   * Code is a rule to replace http status code in response. +optional
   * @type {number}
   * @memberof V1alpha1PodHttpChaosReplaceActions
   */
  code?: number
  /**
   * Headers is a rule to replace http headers of target. The key-value pairs represent header name and header value pairs. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PodHttpChaosReplaceActions
   */
  headers?: { [key: string]: string }
  /**
   * Method is a rule to replace http method in request. +optional
   * @type {string}
   * @memberof V1alpha1PodHttpChaosReplaceActions
   */
  method?: string
  /**
   * Path is rule to to replace uri path in http request. +optional
   * @type {string}
   * @memberof V1alpha1PodHttpChaosReplaceActions
   */
  path?: string
  /**
   * Queries is a rule to replace uri queries in http request. For example, with value `{ \"foo\": \"unknown\" }`, the `/?foo=bar` will be altered to `/?foo=unknown`, +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PodHttpChaosReplaceActions
   */
  queries?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface V1alpha1PodSelector
 */
export interface V1alpha1PodSelector {
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1PodSelector
   */
  mode?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1PodSelector
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1PodSelector
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1PodSelectorSpec
 */
export interface V1alpha1PodSelectorSpec {
  /**
   * Map of string keys and values that can be used to select objects. A selector based on annotations. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PodSelectorSpec
   */
  annotationSelectors?: { [key: string]: string }
  /**
   * Map of string keys and values that can be used to select objects. A selector based on fields. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PodSelectorSpec
   */
  fieldSelectors?: { [key: string]: string }
  /**
   * Map of string keys and values that can be used to select objects. A selector based on labels. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PodSelectorSpec
   */
  labelSelectors?: { [key: string]: string }
  /**
   * Namespaces is a set of namespace to which objects belong. +optional
   * @type {Array<string>}
   * @memberof V1alpha1PodSelectorSpec
   */
  namespaces?: Array<string>
  /**
   * Map of string keys and values that can be used to select nodes. Selector which must match a node\'s labels, and objects must belong to these selected nodes. +optional
   * @type {{ [key: string]: string; }}
   * @memberof V1alpha1PodSelectorSpec
   */
  nodeSelectors?: { [key: string]: string }
  /**
   * Nodes is a set of node name and objects must belong to these nodes. +optional
   * @type {Array<string>}
   * @memberof V1alpha1PodSelectorSpec
   */
  nodes?: Array<string>
  /**
   * PodPhaseSelectors is a set of condition of a pod at the current time. supported value: Pending / Running / Succeeded / Failed / Unknown +optional
   * @type {Array<string>}
   * @memberof V1alpha1PodSelectorSpec
   */
  podPhaseSelectors?: Array<string>
  /**
   * Pods is a map of string keys and a set values that used to select pods. The key defines the namespace which pods belong, and the each values is a set of pod names. +optional
   * @type {{ [key: string]: Array<string>; }}
   * @memberof V1alpha1PodSelectorSpec
   */
  pods?: { [key: string]: Array<string> }
}
/**
 *
 * @export
 * @interface V1alpha1ProcessSpec
 */
export interface V1alpha1ProcessSpec {
  /**
   * the process name or the process ID
   * @type {string}
   * @memberof V1alpha1ProcessSpec
   */
  process?: string
  /**
   * the command to be run when recovering experiment
   * @type {string}
   * @memberof V1alpha1ProcessSpec
   */
  recoverCmd?: string
  /**
   * the signal number to send
   * @type {number}
   * @memberof V1alpha1ProcessSpec
   */
  signal?: number
}
/**
 *
 * @export
 * @interface V1alpha1ReorderSpec
 */
export interface V1alpha1ReorderSpec {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1ReorderSpec
   */
  correlation?: string
  /**
   *
   * @type {number}
   * @memberof V1alpha1ReorderSpec
   */
  gap?: number
  /**
   *
   * @type {string}
   * @memberof V1alpha1ReorderSpec
   */
  reorder?: string
}
/**
 *
 * @export
 * @interface V1alpha1Schedule
 */
export interface V1alpha1Schedule {
  /**
   *
   * @type {V1alpha1ScheduleSpec}
   * @memberof V1alpha1Schedule
   */
  spec?: V1alpha1ScheduleSpec
  /**
   *
   * @type {V1alpha1ScheduleStatus}
   * @memberof V1alpha1Schedule
   */
  status?: V1alpha1ScheduleStatus
}
/**
 *
 * @export
 * @interface V1alpha1ScheduleSpec
 */
export interface V1alpha1ScheduleSpec {
  /**
   *
   * @type {V1alpha1AWSChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  awsChaos?: V1alpha1AWSChaosSpec
  /**
   *
   * @type {V1alpha1AzureChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  azureChaos?: V1alpha1AzureChaosSpec
  /**
   *
   * @type {V1alpha1BlockChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  blockChaos?: V1alpha1BlockChaosSpec
  /**
   * +optional +kubebuilder:default=Forbid +kubebuilder:validation:Enum=Forbid;Allow
   * @type {string}
   * @memberof V1alpha1ScheduleSpec
   */
  concurrencyPolicy?: string
  /**
   *
   * @type {V1alpha1DNSChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  dnsChaos?: V1alpha1DNSChaosSpec
  /**
   *
   * @type {V1alpha1GCPChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  gcpChaos?: V1alpha1GCPChaosSpec
  /**
   * +optional +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1ScheduleSpec
   */
  historyLimit?: number
  /**
   *
   * @type {V1alpha1HTTPChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  httpChaos?: V1alpha1HTTPChaosSpec
  /**
   *
   * @type {V1alpha1IOChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  ioChaos?: V1alpha1IOChaosSpec
  /**
   *
   * @type {V1alpha1JVMChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  jvmChaos?: V1alpha1JVMChaosSpec
  /**
   *
   * @type {V1alpha1KernelChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  kernelChaos?: V1alpha1KernelChaosSpec
  /**
   *
   * @type {V1alpha1NetworkChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  networkChaos?: V1alpha1NetworkChaosSpec
  /**
   *
   * @type {V1alpha1PhysicalMachineChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  physicalmachineChaos?: V1alpha1PhysicalMachineChaosSpec
  /**
   *
   * @type {V1alpha1PodChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  podChaos?: V1alpha1PodChaosSpec
  /**
   *
   * @type {string}
   * @memberof V1alpha1ScheduleSpec
   */
  schedule?: string
  /**
   * +optional +nullable +kubebuilder:validation:Minimum=0 +kubebuilder:validation:ExclusiveMinimum=true
   * @type {number}
   * @memberof V1alpha1ScheduleSpec
   */
  startingDeadlineSeconds?: number
  /**
   *
   * @type {V1alpha1StressChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  stressChaos?: V1alpha1StressChaosSpec
  /**
   *
   * @type {V1alpha1TimeChaosSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  timeChaos?: V1alpha1TimeChaosSpec
  /**
   * TODO: use a custom type, as `TemplateType` contains other possible values
   * @type {string}
   * @memberof V1alpha1ScheduleSpec
   */
  type?: string
  /**
   *
   * @type {V1alpha1WorkflowSpec}
   * @memberof V1alpha1ScheduleSpec
   */
  workflow?: V1alpha1WorkflowSpec
}
/**
 *
 * @export
 * @interface V1alpha1ScheduleStatus
 */
export interface V1alpha1ScheduleStatus {
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1ScheduleStatus
   */
  active?: string
  /**
   * +optional +nullable
   * @type {string}
   * @memberof V1alpha1ScheduleStatus
   */
  time?: string
}
/**
 *
 * @export
 * @interface V1alpha1StatusCheckSpec
 */
export interface V1alpha1StatusCheckSpec {
  /**
   * Duration defines the duration of the whole status check if the number of failed execution does not exceed the failure threshold. Duration is available to both `Synchronous` and `Continuous` mode. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". +optional
   * @type {string}
   * @memberof V1alpha1StatusCheckSpec
   */
  duration?: string
  /**
   * FailureThreshold defines the minimum consecutive failure for the status check to be considered failed. +optional +kubebuilder:default=3 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckSpec
   */
  failureThreshold?: number
  /**
   *
   * @type {V1alpha1HTTPStatusCheck}
   * @memberof V1alpha1StatusCheckSpec
   */
  http?: V1alpha1HTTPStatusCheck
  /**
   * IntervalSeconds defines how often (in seconds) to perform an execution of status check. +optional +kubebuilder:default=10 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckSpec
   */
  intervalSeconds?: number
  /**
   * Mode defines the execution mode of the status check. Support type: Synchronous / Continuous +optional +kubebuilder:validation:Enum=Synchronous;Continuous
   * @type {string}
   * @memberof V1alpha1StatusCheckSpec
   */
  mode?: string
  /**
   * RecordsHistoryLimit defines the number of record to retain. +optional +kubebuilder:default=100 +kubebuilder:validation:Minimum=1 +kubebuilder:validation:Maximum=1000
   * @type {number}
   * @memberof V1alpha1StatusCheckSpec
   */
  recordsHistoryLimit?: number
  /**
   * SuccessThreshold defines the minimum consecutive successes for the status check to be considered successful. SuccessThreshold only works for `Synchronous` mode. +optional +kubebuilder:default=1 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckSpec
   */
  successThreshold?: number
  /**
   * TimeoutSeconds defines the number of seconds after which an execution of status check times out. +optional +kubebuilder:default=1 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckSpec
   */
  timeoutSeconds?: number
  /**
   * Type defines the specific status check type. Support type: HTTP +kubebuilder:default=HTTP +kubebuilder:validation:Enum=HTTP
   * @type {string}
   * @memberof V1alpha1StatusCheckSpec
   */
  type?: string
}
/**
 *
 * @export
 * @interface V1alpha1StatusCheckTemplate
 */
export interface V1alpha1StatusCheckTemplate {
  /**
   * Duration defines the duration of the whole status check if the number of failed execution does not exceed the failure threshold. Duration is available to both `Synchronous` and `Continuous` mode. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". +optional
   * @type {string}
   * @memberof V1alpha1StatusCheckTemplate
   */
  duration?: string
  /**
   * FailureThreshold defines the minimum consecutive failure for the status check to be considered failed. +optional +kubebuilder:default=3 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckTemplate
   */
  failureThreshold?: number
  /**
   *
   * @type {V1alpha1HTTPStatusCheck}
   * @memberof V1alpha1StatusCheckTemplate
   */
  http?: V1alpha1HTTPStatusCheck
  /**
   * IntervalSeconds defines how often (in seconds) to perform an execution of status check. +optional +kubebuilder:default=10 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckTemplate
   */
  intervalSeconds?: number
  /**
   * Mode defines the execution mode of the status check. Support type: Synchronous / Continuous +optional +kubebuilder:validation:Enum=Synchronous;Continuous
   * @type {string}
   * @memberof V1alpha1StatusCheckTemplate
   */
  mode?: string
  /**
   * RecordsHistoryLimit defines the number of record to retain. +optional +kubebuilder:default=100 +kubebuilder:validation:Minimum=1 +kubebuilder:validation:Maximum=1000
   * @type {number}
   * @memberof V1alpha1StatusCheckTemplate
   */
  recordsHistoryLimit?: number
  /**
   * SuccessThreshold defines the minimum consecutive successes for the status check to be considered successful. SuccessThreshold only works for `Synchronous` mode. +optional +kubebuilder:default=1 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckTemplate
   */
  successThreshold?: number
  /**
   * TimeoutSeconds defines the number of seconds after which an execution of status check times out. +optional +kubebuilder:default=1 +kubebuilder:validation:Minimum=1
   * @type {number}
   * @memberof V1alpha1StatusCheckTemplate
   */
  timeoutSeconds?: number
  /**
   * Type defines the specific status check type. Support type: HTTP +kubebuilder:default=HTTP +kubebuilder:validation:Enum=HTTP
   * @type {string}
   * @memberof V1alpha1StatusCheckTemplate
   */
  type?: string
}
/**
 *
 * @export
 * @interface V1alpha1StressCPUSpec
 */
export interface V1alpha1StressCPUSpec {
  /**
   * specifies P percent loading per CPU worker. 0 is effectively a sleep (no load) and 100 is full loading.
   * @type {number}
   * @memberof V1alpha1StressCPUSpec
   */
  load?: number
  /**
   * extend stress-ng options
   * @type {string}
   * @memberof V1alpha1StressCPUSpec
   */
  options?: string
  /**
   * specifies N workers to apply the stressor.
   * @type {number}
   * @memberof V1alpha1StressCPUSpec
   */
  workers?: number
}
/**
 *
 * @export
 * @interface V1alpha1StressChaosSpec
 */
export interface V1alpha1StressChaosSpec {
  /**
   * ContainerNames indicates list of the name of affected container. If not set, the first container will be injected +optional
   * @type {Array<string>}
   * @memberof V1alpha1StressChaosSpec
   */
  containerNames?: Array<string>
  /**
   * Duration represents the duration of the chaos action +optional
   * @type {string}
   * @memberof V1alpha1StressChaosSpec
   */
  duration?: string
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1StressChaosSpec
   */
  mode?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1StressChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * StressngStressors defines plenty of stressors just like `Stressors` except that it\'s an experimental feature and more powerful. You can define stressors in `stress-ng` (see also `man stress-ng`) dialect, however not all of the supported stressors are well tested. It maybe retired in later releases. You should always use `Stressors` to define the stressors and use this only when you want more stressors unsupported by `Stressors`. When both `StressngStressors` and `Stressors` are defined, `StressngStressors` wins. +optional
   * @type {string}
   * @memberof V1alpha1StressChaosSpec
   */
  stressngStressors?: string
  /**
   *
   * @type {V1alpha1Stressors}
   * @memberof V1alpha1StressChaosSpec
   */
  stressors?: V1alpha1Stressors
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1StressChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1StressMemorySpec
 */
export interface V1alpha1StressMemorySpec {
  /**
   * extend stress-ng options
   * @type {string}
   * @memberof V1alpha1StressMemorySpec
   */
  options?: string
  /**
   * specifies N bytes consumed per vm worker, default is the total available memory. One can specify the size as % of total available memory or in units of B, KB/KiB, MB/MiB, GB/GiB, TB/TiB..
   * @type {string}
   * @memberof V1alpha1StressMemorySpec
   */
  size?: string
}
/**
 *
 * @export
 * @interface V1alpha1Stressors
 */
export interface V1alpha1Stressors {
  /**
   *
   * @type {V1alpha1CPUStressor}
   * @memberof V1alpha1Stressors
   */
  cpu?: V1alpha1CPUStressor
  /**
   *
   * @type {V1alpha1MemoryStressor}
   * @memberof V1alpha1Stressors
   */
  memory?: V1alpha1MemoryStressor
}
/**
 *
 * @export
 * @interface V1alpha1Task
 */
export interface V1alpha1Task {
  /**
   * Container is the main container image to run in the pod
   * @type {string}
   * @memberof V1alpha1Task
   */
  container?: string
  /**
   * Volumes is a list of volumes that can be mounted by containers in a template. +patchStrategy=merge +patchMergeKey=name
   * @type {string}
   * @memberof V1alpha1Task
   */
  volumes?: string
}
/**
 *
 * @export
 * @interface V1alpha1Template
 */
export interface V1alpha1Template {
  /**
   * AbortWithStatusCheck describe whether to abort the workflow when the failure threshold of StatusCheck is exceeded. Only used when Type is TypeStatusCheck. +optional
   * @type {boolean}
   * @memberof V1alpha1Template
   */
  abortWithStatusCheck?: boolean
  /**
   *
   * @type {V1alpha1AWSChaosSpec}
   * @memberof V1alpha1Template
   */
  awsChaos?: V1alpha1AWSChaosSpec
  /**
   *
   * @type {V1alpha1AzureChaosSpec}
   * @memberof V1alpha1Template
   */
  azureChaos?: V1alpha1AzureChaosSpec
  /**
   *
   * @type {V1alpha1BlockChaosSpec}
   * @memberof V1alpha1Template
   */
  blockChaos?: V1alpha1BlockChaosSpec
  /**
   * Children describes the children steps of serial or parallel node. Only used when Type is TypeSerial or TypeParallel. +optional
   * @type {Array<string>}
   * @memberof V1alpha1Template
   */
  children?: Array<string>
  /**
   * ConditionalBranches describes the conditional branches of custom tasks. Only used when Type is TypeTask. +optional
   * @type {Array<V1alpha1ConditionalBranch>}
   * @memberof V1alpha1Template
   */
  conditionalBranches?: Array<V1alpha1ConditionalBranch>
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1Template
   */
  deadline?: string
  /**
   *
   * @type {V1alpha1DNSChaosSpec}
   * @memberof V1alpha1Template
   */
  dnsChaos?: V1alpha1DNSChaosSpec
  /**
   *
   * @type {V1alpha1GCPChaosSpec}
   * @memberof V1alpha1Template
   */
  gcpChaos?: V1alpha1GCPChaosSpec
  /**
   *
   * @type {V1alpha1HTTPChaosSpec}
   * @memberof V1alpha1Template
   */
  httpChaos?: V1alpha1HTTPChaosSpec
  /**
   *
   * @type {V1alpha1IOChaosSpec}
   * @memberof V1alpha1Template
   */
  ioChaos?: V1alpha1IOChaosSpec
  /**
   *
   * @type {V1alpha1JVMChaosSpec}
   * @memberof V1alpha1Template
   */
  jvmChaos?: V1alpha1JVMChaosSpec
  /**
   *
   * @type {V1alpha1KernelChaosSpec}
   * @memberof V1alpha1Template
   */
  kernelChaos?: V1alpha1KernelChaosSpec
  /**
   *
   * @type {string}
   * @memberof V1alpha1Template
   */
  name?: string
  /**
   *
   * @type {V1alpha1NetworkChaosSpec}
   * @memberof V1alpha1Template
   */
  networkChaos?: V1alpha1NetworkChaosSpec
  /**
   *
   * @type {V1alpha1PhysicalMachineChaosSpec}
   * @memberof V1alpha1Template
   */
  physicalmachineChaos?: V1alpha1PhysicalMachineChaosSpec
  /**
   *
   * @type {V1alpha1PodChaosSpec}
   * @memberof V1alpha1Template
   */
  podChaos?: V1alpha1PodChaosSpec
  /**
   *
   * @type {V1alpha1ChaosOnlyScheduleSpec}
   * @memberof V1alpha1Template
   */
  schedule?: V1alpha1ChaosOnlyScheduleSpec
  /**
   *
   * @type {V1alpha1StatusCheckSpec}
   * @memberof V1alpha1Template
   */
  statusCheck?: V1alpha1StatusCheckSpec
  /**
   *
   * @type {V1alpha1StressChaosSpec}
   * @memberof V1alpha1Template
   */
  stressChaos?: V1alpha1StressChaosSpec
  /**
   *
   * @type {V1alpha1Task}
   * @memberof V1alpha1Template
   */
  task?: V1alpha1Task
  /**
   *
   * @type {string}
   * @memberof V1alpha1Template
   */
  templateType?: string
  /**
   *
   * @type {V1alpha1TimeChaosSpec}
   * @memberof V1alpha1Template
   */
  timeChaos?: V1alpha1TimeChaosSpec
}
/**
 *
 * @export
 * @interface V1alpha1TimeChaosSpec
 */
export interface V1alpha1TimeChaosSpec {
  /**
   * ClockIds defines all affected clock id All available options are [\"CLOCK_REALTIME\",\"CLOCK_MONOTONIC\",\"CLOCK_PROCESS_CPUTIME_ID\",\"CLOCK_THREAD_CPUTIME_ID\", \"CLOCK_MONOTONIC_RAW\",\"CLOCK_REALTIME_COARSE\",\"CLOCK_MONOTONIC_COARSE\",\"CLOCK_BOOTTIME\",\"CLOCK_REALTIME_ALARM\", \"CLOCK_BOOTTIME_ALARM\"] Default value is [\"CLOCK_REALTIME\"]
   * @type {Array<string>}
   * @memberof V1alpha1TimeChaosSpec
   */
  clockIds?: Array<string>
  /**
   * ContainerNames indicates list of the name of affected container. If not set, the first container will be injected +optional
   * @type {Array<string>}
   * @memberof V1alpha1TimeChaosSpec
   */
  containerNames?: Array<string>
  /**
   * Duration represents the duration of the chaos action
   * @type {string}
   * @memberof V1alpha1TimeChaosSpec
   */
  duration?: string
  /**
   * Mode defines the mode to run chaos action. Supported mode: one / all / fixed / fixed-percent / random-max-percent +kubebuilder:validation:Enum=one;all;fixed;fixed-percent;random-max-percent
   * @type {string}
   * @memberof V1alpha1TimeChaosSpec
   */
  mode?: string
  /**
   *
   * @type {V1alpha1PodSelectorSpec}
   * @memberof V1alpha1TimeChaosSpec
   */
  selector?: V1alpha1PodSelectorSpec
  /**
   * TimeOffset defines the delta time of injected program. It\'s a possibly signed sequence of decimal numbers, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".
   * @type {string}
   * @memberof V1alpha1TimeChaosSpec
   */
  timeOffset?: string
  /**
   * Value is required when the mode is set to `FixedMode` / `FixedPercentMode` / `RandomMaxPercentMode`. If `FixedMode`, provide an integer of pods to do chaos action. If `FixedPercentMode`, provide a number from 0-100 to specify the percent of pods the server can do chaos action. IF `RandomMaxPercentMode`,  provide a number from 0-100 to specify the max percent of pods to do chaos action +optional
   * @type {string}
   * @memberof V1alpha1TimeChaosSpec
   */
  value?: string
}
/**
 *
 * @export
 * @interface V1alpha1Timespec
 */
export interface V1alpha1Timespec {
  /**
   *
   * @type {number}
   * @memberof V1alpha1Timespec
   */
  nsec?: number
  /**
   *
   * @type {number}
   * @memberof V1alpha1Timespec
   */
  sec?: number
}
/**
 *
 * @export
 * @interface V1alpha1Workflow
 */
export interface V1alpha1Workflow {
  /**
   *
   * @type {V1alpha1WorkflowSpec}
   * @memberof V1alpha1Workflow
   */
  spec?: V1alpha1WorkflowSpec
  /**
   *
   * @type {V1alpha1WorkflowStatus}
   * @memberof V1alpha1Workflow
   */
  status?: V1alpha1WorkflowStatus
}
/**
 *
 * @export
 * @interface V1alpha1WorkflowCondition
 */
export interface V1alpha1WorkflowCondition {
  /**
   *
   * @type {string}
   * @memberof V1alpha1WorkflowCondition
   */
  reason?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1WorkflowCondition
   */
  startTime?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1WorkflowCondition
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof V1alpha1WorkflowCondition
   */
  type?: string
}
/**
 *
 * @export
 * @interface V1alpha1WorkflowSpec
 */
export interface V1alpha1WorkflowSpec {
  /**
   *
   * @type {string}
   * @memberof V1alpha1WorkflowSpec
   */
  entry?: string
  /**
   *
   * @type {Array<V1alpha1Template>}
   * @memberof V1alpha1WorkflowSpec
   */
  templates?: Array<V1alpha1Template>
}
/**
 *
 * @export
 * @interface V1alpha1WorkflowStatus
 */
export interface V1alpha1WorkflowStatus {
  /**
   * Represents the latest available observations of a workflow\'s current state. +optional +patchMergeKey=type +patchStrategy=merge
   * @type {Array<V1alpha1WorkflowCondition>}
   * @memberof V1alpha1WorkflowStatus
   */
  conditions?: Array<V1alpha1WorkflowCondition>
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1WorkflowStatus
   */
  endTime?: string
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1WorkflowStatus
   */
  entryNode?: string
  /**
   * +optional
   * @type {string}
   * @memberof V1alpha1WorkflowStatus
   */
  startTime?: string
}
/**
 *
 * @export
 * @interface WorkflowStatusResponse
 */
export interface WorkflowStatusResponse {
  /**
   *
   * @type {string}
   * @memberof WorkflowStatusResponse
   */
  status?: string
}

/**
 * ArchivesApi - axios parameter creator
 * @export
 */
export const ArchivesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete the specified archived experiment.
     * @summary Delete the specified archived experiment.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesDelete: async (uids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uids' is not null or undefined
      assertParamExists('archivesDelete', 'uids', uids)
      const localVarPath = `/archives`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (uids !== undefined) {
        localVarQueryParameter['uids'] = uids
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get archived chaos experiments.
     * @summary Get archived chaos experiments.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos'} [kind] kind
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesGet: async (
      namespace?: string,
      name?: string,
      kind?: 'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/archives`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (kind !== undefined) {
        localVarQueryParameter['kind'] = kind
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the specified archived schedule.
     * @summary Delete the specified archived schedule.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesDelete: async (uids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uids' is not null or undefined
      assertParamExists('archivesSchedulesDelete', 'uids', uids)
      const localVarPath = `/archives/schedules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (uids !== undefined) {
        localVarQueryParameter['uids'] = uids
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get archived schedule experiments.
     * @summary Get archived schedule experiments.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesGet: async (
      namespace?: string,
      name?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/archives/schedules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the specified archived schedule.
     * @summary Delete the specified archived schedule.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesUidDelete: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('archivesSchedulesUidDelete', 'uid', uid)
      const localVarPath = `/archives/schedules/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the detail of an archived schedule experiment.
     * @summary Get the detail of an archived schedule experiment.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesUidGet: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('archivesSchedulesUidGet', 'uid', uid)
      const localVarPath = `/archives/schedules/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the specified archived experiment.
     * @summary Delete the specified archived experiment.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesUidDelete: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('archivesUidDelete', 'uid', uid)
      const localVarPath = `/archives/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the archived chaos experiment\'s detail by uid.
     * @summary Get an archived chaos experiment.
     * @param {string} uid the archive uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesUidGet: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('archivesUidGet', 'uid', uid)
      const localVarPath = `/archives/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the specified archived workflows.
     * @summary Delete the specified archived workflows.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsDelete: async (uids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uids' is not null or undefined
      assertParamExists('archivesWorkflowsDelete', 'uids', uids)
      const localVarPath = `/archives/workflows`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (uids !== undefined) {
        localVarQueryParameter['uids'] = uids
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get archived workflow.
     * @summary Get archived workflow.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsGet: async (
      namespace?: string,
      name?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/archives/workflows`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the specified archived workflow.
     * @summary Delete the specified archived workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsUidDelete: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('archivesWorkflowsUidDelete', 'uid', uid)
      const localVarPath = `/archives/workflows/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the detail of an archived workflow.
     * @summary Get the detail of an archived workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsUidGet: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('archivesWorkflowsUidGet', 'uid', uid)
      const localVarPath = `/archives/workflows/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ArchivesApi - functional programming interface
 * @export
 */
export const ArchivesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ArchivesApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete the specified archived experiment.
     * @summary Delete the specified archived experiment.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesDelete(
      uids: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesDelete(uids, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get archived chaos experiments.
     * @summary Get archived chaos experiments.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos'} [kind] kind
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesGet(
      namespace?: string,
      name?: string,
      kind?: 'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoreObjectBase>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesGet(namespace, name, kind, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the specified archived schedule.
     * @summary Delete the specified archived schedule.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesSchedulesDelete(
      uids: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesSchedulesDelete(uids, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get archived schedule experiments.
     * @summary Get archived schedule experiments.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesSchedulesGet(
      namespace?: string,
      name?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoreObjectBase>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesSchedulesGet(namespace, name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the specified archived schedule.
     * @summary Delete the specified archived schedule.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesSchedulesUidDelete(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesSchedulesUidDelete(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the detail of an archived schedule experiment.
     * @summary Get the detail of an archived schedule experiment.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesSchedulesUidGet(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArchiveDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesSchedulesUidGet(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the specified archived experiment.
     * @summary Delete the specified archived experiment.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesUidDelete(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesUidDelete(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the archived chaos experiment\'s detail by uid.
     * @summary Get an archived chaos experiment.
     * @param {string} uid the archive uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesUidGet(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArchiveDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesUidGet(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the specified archived workflows.
     * @summary Delete the specified archived workflows.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesWorkflowsDelete(
      uids: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesWorkflowsDelete(uids, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get archived workflow.
     * @summary Get archived workflow.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesWorkflowsGet(
      namespace?: string,
      name?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoreObjectBase>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesWorkflowsGet(namespace, name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the specified archived workflow.
     * @summary Delete the specified archived workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesWorkflowsUidDelete(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesWorkflowsUidDelete(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the detail of an archived workflow.
     * @summary Get the detail of an archived workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async archivesWorkflowsUidGet(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArchiveDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.archivesWorkflowsUidGet(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ArchivesApi - factory interface
 * @export
 */
export const ArchivesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ArchivesApiFp(configuration)
  return {
    /**
     * Delete the specified archived experiment.
     * @summary Delete the specified archived experiment.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesDelete(uids: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.archivesDelete(uids, options).then((request) => request(axios, basePath))
    },
    /**
     * Get archived chaos experiments.
     * @summary Get archived chaos experiments.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos'} [kind] kind
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesGet(
      namespace?: string,
      name?: string,
      kind?: 'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos',
      options?: any
    ): AxiosPromise<Array<CoreObjectBase>> {
      return localVarFp.archivesGet(namespace, name, kind, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the specified archived schedule.
     * @summary Delete the specified archived schedule.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesDelete(uids: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.archivesSchedulesDelete(uids, options).then((request) => request(axios, basePath))
    },
    /**
     * Get archived schedule experiments.
     * @summary Get archived schedule experiments.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesGet(namespace?: string, name?: string, options?: any): AxiosPromise<Array<CoreObjectBase>> {
      return localVarFp.archivesSchedulesGet(namespace, name, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the specified archived schedule.
     * @summary Delete the specified archived schedule.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesUidDelete(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.archivesSchedulesUidDelete(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the detail of an archived schedule experiment.
     * @summary Get the detail of an archived schedule experiment.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesSchedulesUidGet(uid: string, options?: any): AxiosPromise<ArchiveDetail> {
      return localVarFp.archivesSchedulesUidGet(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the specified archived experiment.
     * @summary Delete the specified archived experiment.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesUidDelete(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.archivesUidDelete(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the archived chaos experiment\'s detail by uid.
     * @summary Get an archived chaos experiment.
     * @param {string} uid the archive uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesUidGet(uid: string, options?: any): AxiosPromise<ArchiveDetail> {
      return localVarFp.archivesUidGet(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the specified archived workflows.
     * @summary Delete the specified archived workflows.
     * @param {string} uids uids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsDelete(uids: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.archivesWorkflowsDelete(uids, options).then((request) => request(axios, basePath))
    },
    /**
     * Get archived workflow.
     * @summary Get archived workflow.
     * @param {string} [namespace] namespace
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsGet(namespace?: string, name?: string, options?: any): AxiosPromise<Array<CoreObjectBase>> {
      return localVarFp.archivesWorkflowsGet(namespace, name, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the specified archived workflow.
     * @summary Delete the specified archived workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsUidDelete(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.archivesWorkflowsUidDelete(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the detail of an archived workflow.
     * @summary Get the detail of an archived workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    archivesWorkflowsUidGet(uid: string, options?: any): AxiosPromise<ArchiveDetail> {
      return localVarFp.archivesWorkflowsUidGet(uid, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ArchivesApi - object-oriented interface
 * @export
 * @class ArchivesApi
 * @extends {BaseAPI}
 */
export class ArchivesApi extends BaseAPI {
  /**
   * Delete the specified archived experiment.
   * @summary Delete the specified archived experiment.
   * @param {string} uids uids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesDelete(uids: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesDelete(uids, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get archived chaos experiments.
   * @summary Get archived chaos experiments.
   * @param {string} [namespace] namespace
   * @param {string} [name] name
   * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos'} [kind] kind
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesGet(
    namespace?: string,
    name?: string,
    kind?: 'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos',
    options?: AxiosRequestConfig
  ) {
    return ArchivesApiFp(this.configuration)
      .archivesGet(namespace, name, kind, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the specified archived schedule.
   * @summary Delete the specified archived schedule.
   * @param {string} uids uids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesSchedulesDelete(uids: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesSchedulesDelete(uids, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get archived schedule experiments.
   * @summary Get archived schedule experiments.
   * @param {string} [namespace] namespace
   * @param {string} [name] name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesSchedulesGet(namespace?: string, name?: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesSchedulesGet(namespace, name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the specified archived schedule.
   * @summary Delete the specified archived schedule.
   * @param {string} uid uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesSchedulesUidDelete(uid: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesSchedulesUidDelete(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the detail of an archived schedule experiment.
   * @summary Get the detail of an archived schedule experiment.
   * @param {string} uid uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesSchedulesUidGet(uid: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesSchedulesUidGet(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the specified archived experiment.
   * @summary Delete the specified archived experiment.
   * @param {string} uid uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesUidDelete(uid: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesUidDelete(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the archived chaos experiment\'s detail by uid.
   * @summary Get an archived chaos experiment.
   * @param {string} uid the archive uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesUidGet(uid: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesUidGet(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the specified archived workflows.
   * @summary Delete the specified archived workflows.
   * @param {string} uids uids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesWorkflowsDelete(uids: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesWorkflowsDelete(uids, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get archived workflow.
   * @summary Get archived workflow.
   * @param {string} [namespace] namespace
   * @param {string} [name] name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesWorkflowsGet(namespace?: string, name?: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesWorkflowsGet(namespace, name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the specified archived workflow.
   * @summary Delete the specified archived workflow.
   * @param {string} uid uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesWorkflowsUidDelete(uid: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesWorkflowsUidDelete(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the detail of an archived workflow.
   * @summary Get the detail of an archived workflow.
   * @param {string} uid uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArchivesApi
   */
  public archivesWorkflowsUidGet(uid: string, options?: AxiosRequestConfig) {
    return ArchivesApiFp(this.configuration)
      .archivesWorkflowsUidGet(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CommonApi - axios parameter creator
 * @export
 */
export const CommonApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get the annotations of the pods in the specified namespace from Kubernetes cluster.
     * @summary Get the annotations of the pods in the specified namespace from Kubernetes cluster.
     * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonAnnotationsGet: async (podNamespaceList: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'podNamespaceList' is not null or undefined
      assertParamExists('commonAnnotationsGet', 'podNamespaceList', podNamespaceList)
      const localVarPath = `/common/annotations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (podNamespaceList !== undefined) {
        localVarQueryParameter['podNamespaceList'] = podNamespaceList
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
     * @summary Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonChaosAvailableNamespacesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/common/chaos-available-namespaces`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the config of Dashboard.
     * @summary Get the config of Dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/common/config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all chaos kinds from Kubernetes cluster.
     * @summary Get all chaos kinds from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonKindsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/common/kinds`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the labels of the pods in the specified namespace from Kubernetes cluster.
     * @summary Get the labels of the pods in the specified namespace from Kubernetes cluster.
     * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonLabelsGet: async (podNamespaceList: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'podNamespaceList' is not null or undefined
      assertParamExists('commonLabelsGet', 'podNamespaceList', podNamespaceList)
      const localVarPath = `/common/labels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (podNamespaceList !== undefined) {
        localVarQueryParameter['podNamespaceList'] = podNamespaceList
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all from Kubernetes cluster.
     * @summary Get all namespaces from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    commonNamespacesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/common/namespaces`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @summary Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPhysicalmachineAnnotationsGet: async (
      physicalMachineNamespaceList: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'physicalMachineNamespaceList' is not null or undefined
      assertParamExists(
        'commonPhysicalmachineAnnotationsGet',
        'physicalMachineNamespaceList',
        physicalMachineNamespaceList
      )
      const localVarPath = `/common/physicalmachine-annotations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (physicalMachineNamespaceList !== undefined) {
        localVarQueryParameter['physicalMachineNamespaceList'] = physicalMachineNamespaceList
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @summary Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPhysicalmachineLabelsGet: async (
      physicalMachineNamespaceList: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'physicalMachineNamespaceList' is not null or undefined
      assertParamExists('commonPhysicalmachineLabelsGet', 'physicalMachineNamespaceList', physicalMachineNamespaceList)
      const localVarPath = `/common/physicalmachine-labels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (physicalMachineNamespaceList !== undefined) {
        localVarQueryParameter['physicalMachineNamespaceList'] = physicalMachineNamespaceList
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get physicalMachines from Kubernetes cluster.
     * @summary Get physicalMachines from Kubernetes cluster.
     * @param {V1alpha1PhysicalMachineSelectorSpec} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPhysicalmachinesPost: async (
      request: V1alpha1PhysicalMachineSelectorSpec,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('commonPhysicalmachinesPost', 'request', request)
      const localVarPath = `/common/physicalmachines`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get pods from Kubernetes cluster.
     * @summary Get pods from Kubernetes cluster.
     * @param {V1alpha1PodSelectorSpec} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPodsPost: async (
      request: V1alpha1PodSelectorSpec,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('commonPodsPost', 'request', request)
      const localVarPath = `/common/pods`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the rbac config according to the user\'s choice.
     * @summary Get the rbac config according to the user\'s choice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonRbacConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/common/rbac-config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CommonApi - functional programming interface
 * @export
 */
export const CommonApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CommonApiAxiosParamCreator(configuration)
  return {
    /**
     * Get the annotations of the pods in the specified namespace from Kubernetes cluster.
     * @summary Get the annotations of the pods in the specified namespace from Kubernetes cluster.
     * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonAnnotationsGet(
      podNamespaceList: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<string> }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonAnnotationsGet(podNamespaceList, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
     * @summary Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonChaosAvailableNamespacesGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonChaosAvailableNamespacesGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the config of Dashboard.
     * @summary Get the config of Dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonConfigGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigChaosDashboardConfig>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonConfigGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get all chaos kinds from Kubernetes cluster.
     * @summary Get all chaos kinds from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonKindsGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonKindsGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the labels of the pods in the specified namespace from Kubernetes cluster.
     * @summary Get the labels of the pods in the specified namespace from Kubernetes cluster.
     * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonLabelsGet(
      podNamespaceList: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<string> }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonLabelsGet(podNamespaceList, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get all from Kubernetes cluster.
     * @summary Get all namespaces from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async commonNamespacesGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonNamespacesGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @summary Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonPhysicalmachineAnnotationsGet(
      physicalMachineNamespaceList: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<string> }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonPhysicalmachineAnnotationsGet(
        physicalMachineNamespaceList,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @summary Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonPhysicalmachineLabelsGet(
      physicalMachineNamespaceList: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<string> }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonPhysicalmachineLabelsGet(
        physicalMachineNamespaceList,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get physicalMachines from Kubernetes cluster.
     * @summary Get physicalMachines from Kubernetes cluster.
     * @param {V1alpha1PhysicalMachineSelectorSpec} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonPhysicalmachinesPost(
      request: V1alpha1PhysicalMachineSelectorSpec,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommonPhysicalMachine>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonPhysicalmachinesPost(request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get pods from Kubernetes cluster.
     * @summary Get pods from Kubernetes cluster.
     * @param {V1alpha1PodSelectorSpec} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonPodsPost(
      request: V1alpha1PodSelectorSpec,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommonPod>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonPodsPost(request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the rbac config according to the user\'s choice.
     * @summary Get the rbac config according to the user\'s choice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commonRbacConfigGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<string> }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commonRbacConfigGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * CommonApi - factory interface
 * @export
 */
export const CommonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CommonApiFp(configuration)
  return {
    /**
     * Get the annotations of the pods in the specified namespace from Kubernetes cluster.
     * @summary Get the annotations of the pods in the specified namespace from Kubernetes cluster.
     * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonAnnotationsGet(podNamespaceList: string, options?: any): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp.commonAnnotationsGet(podNamespaceList, options).then((request) => request(axios, basePath))
    },
    /**
     * Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
     * @summary Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonChaosAvailableNamespacesGet(options?: any): AxiosPromise<Array<string>> {
      return localVarFp.commonChaosAvailableNamespacesGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Get the config of Dashboard.
     * @summary Get the config of Dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonConfigGet(options?: any): AxiosPromise<ConfigChaosDashboardConfig> {
      return localVarFp.commonConfigGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Get all chaos kinds from Kubernetes cluster.
     * @summary Get all chaos kinds from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonKindsGet(options?: any): AxiosPromise<Array<string>> {
      return localVarFp.commonKindsGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Get the labels of the pods in the specified namespace from Kubernetes cluster.
     * @summary Get the labels of the pods in the specified namespace from Kubernetes cluster.
     * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonLabelsGet(podNamespaceList: string, options?: any): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp.commonLabelsGet(podNamespaceList, options).then((request) => request(axios, basePath))
    },
    /**
     * Get all from Kubernetes cluster.
     * @summary Get all namespaces from Kubernetes cluster.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    commonNamespacesGet(options?: any): AxiosPromise<Array<string>> {
      return localVarFp.commonNamespacesGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @summary Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPhysicalmachineAnnotationsGet(
      physicalMachineNamespaceList: string,
      options?: any
    ): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp
        .commonPhysicalmachineAnnotationsGet(physicalMachineNamespaceList, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @summary Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
     * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPhysicalmachineLabelsGet(
      physicalMachineNamespaceList: string,
      options?: any
    ): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp
        .commonPhysicalmachineLabelsGet(physicalMachineNamespaceList, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get physicalMachines from Kubernetes cluster.
     * @summary Get physicalMachines from Kubernetes cluster.
     * @param {V1alpha1PhysicalMachineSelectorSpec} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPhysicalmachinesPost(
      request: V1alpha1PhysicalMachineSelectorSpec,
      options?: any
    ): AxiosPromise<Array<CommonPhysicalMachine>> {
      return localVarFp.commonPhysicalmachinesPost(request, options).then((request) => request(axios, basePath))
    },
    /**
     * Get pods from Kubernetes cluster.
     * @summary Get pods from Kubernetes cluster.
     * @param {V1alpha1PodSelectorSpec} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonPodsPost(request: V1alpha1PodSelectorSpec, options?: any): AxiosPromise<Array<CommonPod>> {
      return localVarFp.commonPodsPost(request, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the rbac config according to the user\'s choice.
     * @summary Get the rbac config according to the user\'s choice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commonRbacConfigGet(options?: any): AxiosPromise<{ [key: string]: Array<string> }> {
      return localVarFp.commonRbacConfigGet(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * CommonApi - object-oriented interface
 * @export
 * @class CommonApi
 * @extends {BaseAPI}
 */
export class CommonApi extends BaseAPI {
  /**
   * Get the annotations of the pods in the specified namespace from Kubernetes cluster.
   * @summary Get the annotations of the pods in the specified namespace from Kubernetes cluster.
   * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonAnnotationsGet(podNamespaceList: string, options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonAnnotationsGet(podNamespaceList, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
   * @summary Get all namespaces which could inject chaos(explosion scope) from Kubernetes cluster.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonChaosAvailableNamespacesGet(options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonChaosAvailableNamespacesGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the config of Dashboard.
   * @summary Get the config of Dashboard.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonConfigGet(options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonConfigGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all chaos kinds from Kubernetes cluster.
   * @summary Get all chaos kinds from Kubernetes cluster.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonKindsGet(options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonKindsGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the labels of the pods in the specified namespace from Kubernetes cluster.
   * @summary Get the labels of the pods in the specified namespace from Kubernetes cluster.
   * @param {string} podNamespaceList The pod\&#39;s namespace list, split by ,
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonLabelsGet(podNamespaceList: string, options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonLabelsGet(podNamespaceList, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get all from Kubernetes cluster.
   * @summary Get all namespaces from Kubernetes cluster.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonNamespacesGet(options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonNamespacesGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
   * @summary Get the annotations of the physicalMachines in the specified namespace from Kubernetes cluster.
   * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonPhysicalmachineAnnotationsGet(physicalMachineNamespaceList: string, options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonPhysicalmachineAnnotationsGet(physicalMachineNamespaceList, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
   * @summary Get the labels of the physicalMachines in the specified namespace from Kubernetes cluster.
   * @param {string} physicalMachineNamespaceList The physicalMachine\&#39;s namespace list, split by ,
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonPhysicalmachineLabelsGet(physicalMachineNamespaceList: string, options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonPhysicalmachineLabelsGet(physicalMachineNamespaceList, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get physicalMachines from Kubernetes cluster.
   * @summary Get physicalMachines from Kubernetes cluster.
   * @param {V1alpha1PhysicalMachineSelectorSpec} request Request body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonPhysicalmachinesPost(request: V1alpha1PhysicalMachineSelectorSpec, options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonPhysicalmachinesPost(request, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get pods from Kubernetes cluster.
   * @summary Get pods from Kubernetes cluster.
   * @param {V1alpha1PodSelectorSpec} request Request body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonPodsPost(request: V1alpha1PodSelectorSpec, options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonPodsPost(request, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the rbac config according to the user\'s choice.
   * @summary Get the rbac config according to the user\'s choice.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public commonRbacConfigGet(options?: AxiosRequestConfig) {
    return CommonApiFp(this.configuration)
      .commonRbacConfigGet(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get events from db.
     * @summary list events.
     * @param {string} [createdAt] The create time of events
     * @param {string} [name] The name of the object
     * @param {string} [namespace] The namespace of the object
     * @param {string} [objectId] The UID of the object
     * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos' | 'AWSChaos' | 'GCPChaos' | 'DNSChaos' | 'Schedule'} [kind] kind
     * @param {string} [limit] The max length of events list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsGet: async (
      createdAt?: string,
      name?: string,
      namespace?: string,
      objectId?: string,
      kind?:
        | 'PodChaos'
        | 'IOChaos'
        | 'NetworkChaos'
        | 'TimeChaos'
        | 'KernelChaos'
        | 'StressChaos'
        | 'AWSChaos'
        | 'GCPChaos'
        | 'DNSChaos'
        | 'Schedule',
      limit?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (createdAt !== undefined) {
        localVarQueryParameter['created_at'] = createdAt
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (objectId !== undefined) {
        localVarQueryParameter['object_id'] = objectId
      }

      if (kind !== undefined) {
        localVarQueryParameter['kind'] = kind
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the event from db by ID.
     * @summary Get an event.
     * @param {number} id The event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('eventsIdGet', 'id', id)
      const localVarPath = `/events/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * list all events for Workflow and related WorkflowNode.
     * @summary cascadeFetchEventsForWorkflow list all events for Workflow and related WorkflowNode.
     * @param {string} uid The UID of the Workflow
     * @param {string} [namespace] The namespace of the object
     * @param {string} [limit] The max length of events list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsWorkflowUidGet: async (
      uid: string,
      namespace?: string,
      limit?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('eventsWorkflowUidGet', 'uid', uid)
      const localVarPath = `/events/workflow/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
  return {
    /**
     * Get events from db.
     * @summary list events.
     * @param {string} [createdAt] The create time of events
     * @param {string} [name] The name of the object
     * @param {string} [namespace] The namespace of the object
     * @param {string} [objectId] The UID of the object
     * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos' | 'AWSChaos' | 'GCPChaos' | 'DNSChaos' | 'Schedule'} [kind] kind
     * @param {string} [limit] The max length of events list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventsGet(
      createdAt?: string,
      name?: string,
      namespace?: string,
      objectId?: string,
      kind?:
        | 'PodChaos'
        | 'IOChaos'
        | 'NetworkChaos'
        | 'TimeChaos'
        | 'KernelChaos'
        | 'StressChaos'
        | 'AWSChaos'
        | 'GCPChaos'
        | 'DNSChaos'
        | 'Schedule',
      limit?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoreEvent>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eventsGet(
        createdAt,
        name,
        namespace,
        objectId,
        kind,
        limit,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the event from db by ID.
     * @summary Get an event.
     * @param {number} id The event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventsIdGet(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreEvent>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdGet(id, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * list all events for Workflow and related WorkflowNode.
     * @summary cascadeFetchEventsForWorkflow list all events for Workflow and related WorkflowNode.
     * @param {string} uid The UID of the Workflow
     * @param {string} [namespace] The namespace of the object
     * @param {string} [limit] The max length of events list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventsWorkflowUidGet(
      uid: string,
      namespace?: string,
      limit?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoreEvent>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eventsWorkflowUidGet(uid, namespace, limit, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EventsApiFp(configuration)
  return {
    /**
     * Get events from db.
     * @summary list events.
     * @param {string} [createdAt] The create time of events
     * @param {string} [name] The name of the object
     * @param {string} [namespace] The namespace of the object
     * @param {string} [objectId] The UID of the object
     * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos' | 'AWSChaos' | 'GCPChaos' | 'DNSChaos' | 'Schedule'} [kind] kind
     * @param {string} [limit] The max length of events list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsGet(
      createdAt?: string,
      name?: string,
      namespace?: string,
      objectId?: string,
      kind?:
        | 'PodChaos'
        | 'IOChaos'
        | 'NetworkChaos'
        | 'TimeChaos'
        | 'KernelChaos'
        | 'StressChaos'
        | 'AWSChaos'
        | 'GCPChaos'
        | 'DNSChaos'
        | 'Schedule',
      limit?: string,
      options?: any
    ): AxiosPromise<Array<CoreEvent>> {
      return localVarFp
        .eventsGet(createdAt, name, namespace, objectId, kind, limit, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get the event from db by ID.
     * @summary Get an event.
     * @param {number} id The event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsIdGet(id: number, options?: any): AxiosPromise<CoreEvent> {
      return localVarFp.eventsIdGet(id, options).then((request) => request(axios, basePath))
    },
    /**
     * list all events for Workflow and related WorkflowNode.
     * @summary cascadeFetchEventsForWorkflow list all events for Workflow and related WorkflowNode.
     * @param {string} uid The UID of the Workflow
     * @param {string} [namespace] The namespace of the object
     * @param {string} [limit] The max length of events list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventsWorkflowUidGet(
      uid: string,
      namespace?: string,
      limit?: string,
      options?: any
    ): AxiosPromise<Array<CoreEvent>> {
      return localVarFp.eventsWorkflowUidGet(uid, namespace, limit, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
  /**
   * Get events from db.
   * @summary list events.
   * @param {string} [createdAt] The create time of events
   * @param {string} [name] The name of the object
   * @param {string} [namespace] The namespace of the object
   * @param {string} [objectId] The UID of the object
   * @param {'PodChaos' | 'IOChaos' | 'NetworkChaos' | 'TimeChaos' | 'KernelChaos' | 'StressChaos' | 'AWSChaos' | 'GCPChaos' | 'DNSChaos' | 'Schedule'} [kind] kind
   * @param {string} [limit] The max length of events list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public eventsGet(
    createdAt?: string,
    name?: string,
    namespace?: string,
    objectId?: string,
    kind?:
      | 'PodChaos'
      | 'IOChaos'
      | 'NetworkChaos'
      | 'TimeChaos'
      | 'KernelChaos'
      | 'StressChaos'
      | 'AWSChaos'
      | 'GCPChaos'
      | 'DNSChaos'
      | 'Schedule',
    limit?: string,
    options?: AxiosRequestConfig
  ) {
    return EventsApiFp(this.configuration)
      .eventsGet(createdAt, name, namespace, objectId, kind, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the event from db by ID.
   * @summary Get an event.
   * @param {number} id The event ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public eventsIdGet(id: number, options?: AxiosRequestConfig) {
    return EventsApiFp(this.configuration)
      .eventsIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * list all events for Workflow and related WorkflowNode.
   * @summary cascadeFetchEventsForWorkflow list all events for Workflow and related WorkflowNode.
   * @param {string} uid The UID of the Workflow
   * @param {string} [namespace] The namespace of the object
   * @param {string} [limit] The max length of events list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public eventsWorkflowUidGet(uid: string, namespace?: string, limit?: string, options?: AxiosRequestConfig) {
    return EventsApiFp(this.configuration)
      .eventsWorkflowUidGet(uid, namespace, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ExperimentsApi - axios parameter creator
 * @export
 */
export const ExperimentsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Batch delete chaos experiments by uids.
     * @summary Batch delete chaos experiments.
     * @param {string} uids the experiment uids, split with comma. Example: ?uids&#x3D;uid1,uid2
     * @param {'true' | 'false'} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsDelete: async (
      uids: string,
      force?: 'true' | 'false',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uids' is not null or undefined
      assertParamExists('experimentsDelete', 'uids', uids)
      const localVarPath = `/experiments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (uids !== undefined) {
        localVarQueryParameter['uids'] = uids
      }

      if (force !== undefined) {
        localVarQueryParameter['force'] = force
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get chaos experiments from k8s clusters in real time.
     * @summary List chaos experiments.
     * @param {string} [namespace] filter exps by namespace
     * @param {string} [name] filter exps by name
     * @param {'PodChaos' | 'NetworkChaos' | 'IOChaos' | 'StressChaos' | 'KernelChaos' | 'TimeChaos' | 'DNSChaos' | 'AWSChaos' | 'GCPChaos' | 'JVMChaos' | 'HTTPChaos'} [kind] filter exps by kind
     * @param {'Injecting' | 'Running' | 'Finished' | 'Paused'} [status] filter exps by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsGet: async (
      namespace?: string,
      name?: string,
      kind?:
        | 'PodChaos'
        | 'NetworkChaos'
        | 'IOChaos'
        | 'StressChaos'
        | 'KernelChaos'
        | 'TimeChaos'
        | 'DNSChaos'
        | 'AWSChaos'
        | 'GCPChaos'
        | 'JVMChaos'
        | 'HTTPChaos',
      status?: 'Injecting' | 'Running' | 'Finished' | 'Paused',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/experiments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (kind !== undefined) {
        localVarQueryParameter['kind'] = kind
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pause a chaos experiment.
     * @summary Pause a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsPauseUidPut: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('experimentsPauseUidPut', 'uid', uid)
      const localVarPath = `/experiments/pause/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pass a JSON object to create a new chaos experiment. The schema for JSON is the same as the YAML schema for the Kubernetes object.
     * @summary Create a new chaos experiment.
     * @param {object} chaos the chaos definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsPost: async (chaos: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'chaos' is not null or undefined
      assertParamExists('experimentsPost', 'chaos', chaos)
      const localVarPath = `/experiments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(chaos, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start a chaos experiment.
     * @summary Start a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsStartUidPut: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('experimentsStartUidPut', 'uid', uid)
      const localVarPath = `/experiments/start/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the status of all experiments.
     * @summary Get the status of all experiments.
     * @param {string} [namespace] namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsStateGet: async (namespace?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/experiments/state`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the chaos experiment by uid.
     * @summary Delete a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {'true' | 'false'} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsUidDelete: async (
      uid: string,
      force?: 'true' | 'false',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('experimentsUidDelete', 'uid', uid)
      const localVarPath = `/experiments/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (force !== undefined) {
        localVarQueryParameter['force'] = force
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the chaos experiment\'s detail by uid.
     * @summary Get a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsUidGet: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('experimentsUidGet', 'uid', uid)
      const localVarPath = `/experiments/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ExperimentsApi - functional programming interface
 * @export
 */
export const ExperimentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExperimentsApiAxiosParamCreator(configuration)
  return {
    /**
     * Batch delete chaos experiments by uids.
     * @summary Batch delete chaos experiments.
     * @param {string} uids the experiment uids, split with comma. Example: ?uids&#x3D;uid1,uid2
     * @param {'true' | 'false'} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsDelete(
      uids: string,
      force?: 'true' | 'false',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsDelete(uids, force, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get chaos experiments from k8s clusters in real time.
     * @summary List chaos experiments.
     * @param {string} [namespace] filter exps by namespace
     * @param {string} [name] filter exps by name
     * @param {'PodChaos' | 'NetworkChaos' | 'IOChaos' | 'StressChaos' | 'KernelChaos' | 'TimeChaos' | 'DNSChaos' | 'AWSChaos' | 'GCPChaos' | 'JVMChaos' | 'HTTPChaos'} [kind] filter exps by kind
     * @param {'Injecting' | 'Running' | 'Finished' | 'Paused'} [status] filter exps by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsGet(
      namespace?: string,
      name?: string,
      kind?:
        | 'PodChaos'
        | 'NetworkChaos'
        | 'IOChaos'
        | 'StressChaos'
        | 'KernelChaos'
        | 'TimeChaos'
        | 'DNSChaos'
        | 'AWSChaos'
        | 'GCPChaos'
        | 'JVMChaos'
        | 'HTTPChaos',
      status?: 'Injecting' | 'Running' | 'Finished' | 'Paused',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExperimentExperiment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsGet(namespace, name, kind, status, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Pause a chaos experiment.
     * @summary Pause a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsPauseUidPut(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsPauseUidPut(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Pass a JSON object to create a new chaos experiment. The schema for JSON is the same as the YAML schema for the Kubernetes object.
     * @summary Create a new chaos experiment.
     * @param {object} chaos the chaos definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsPost(
      chaos: object,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsPost(chaos, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Start a chaos experiment.
     * @summary Start a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsStartUidPut(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsStartUidPut(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the status of all experiments.
     * @summary Get the status of all experiments.
     * @param {string} [namespace] namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsStateGet(
      namespace?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusAllChaosStatus>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsStateGet(namespace, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the chaos experiment by uid.
     * @summary Delete a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {'true' | 'false'} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsUidDelete(
      uid: string,
      force?: 'true' | 'false',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsUidDelete(uid, force, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the chaos experiment\'s detail by uid.
     * @summary Get a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async experimentsUidGet(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.experimentsUidGet(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ExperimentsApi - factory interface
 * @export
 */
export const ExperimentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExperimentsApiFp(configuration)
  return {
    /**
     * Batch delete chaos experiments by uids.
     * @summary Batch delete chaos experiments.
     * @param {string} uids the experiment uids, split with comma. Example: ?uids&#x3D;uid1,uid2
     * @param {'true' | 'false'} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsDelete(uids: string, force?: 'true' | 'false', options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.experimentsDelete(uids, force, options).then((request) => request(axios, basePath))
    },
    /**
     * Get chaos experiments from k8s clusters in real time.
     * @summary List chaos experiments.
     * @param {string} [namespace] filter exps by namespace
     * @param {string} [name] filter exps by name
     * @param {'PodChaos' | 'NetworkChaos' | 'IOChaos' | 'StressChaos' | 'KernelChaos' | 'TimeChaos' | 'DNSChaos' | 'AWSChaos' | 'GCPChaos' | 'JVMChaos' | 'HTTPChaos'} [kind] filter exps by kind
     * @param {'Injecting' | 'Running' | 'Finished' | 'Paused'} [status] filter exps by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsGet(
      namespace?: string,
      name?: string,
      kind?:
        | 'PodChaos'
        | 'NetworkChaos'
        | 'IOChaos'
        | 'StressChaos'
        | 'KernelChaos'
        | 'TimeChaos'
        | 'DNSChaos'
        | 'AWSChaos'
        | 'GCPChaos'
        | 'JVMChaos'
        | 'HTTPChaos',
      status?: 'Injecting' | 'Running' | 'Finished' | 'Paused',
      options?: any
    ): AxiosPromise<Array<ExperimentExperiment>> {
      return localVarFp
        .experimentsGet(namespace, name, kind, status, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Pause a chaos experiment.
     * @summary Pause a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsPauseUidPut(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.experimentsPauseUidPut(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Pass a JSON object to create a new chaos experiment. The schema for JSON is the same as the YAML schema for the Kubernetes object.
     * @summary Create a new chaos experiment.
     * @param {object} chaos the chaos definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsPost(chaos: object, options?: any): AxiosPromise<object> {
      return localVarFp.experimentsPost(chaos, options).then((request) => request(axios, basePath))
    },
    /**
     * Start a chaos experiment.
     * @summary Start a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsStartUidPut(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.experimentsStartUidPut(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the status of all experiments.
     * @summary Get the status of all experiments.
     * @param {string} [namespace] namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsStateGet(namespace?: string, options?: any): AxiosPromise<StatusAllChaosStatus> {
      return localVarFp.experimentsStateGet(namespace, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the chaos experiment by uid.
     * @summary Delete a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {'true' | 'false'} [force] force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsUidDelete(uid: string, force?: 'true' | 'false', options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.experimentsUidDelete(uid, force, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the chaos experiment\'s detail by uid.
     * @summary Get a chaos experiment.
     * @param {string} uid the experiment uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    experimentsUidGet(uid: string, options?: any): AxiosPromise<ExperimentDetail> {
      return localVarFp.experimentsUidGet(uid, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ExperimentsApi - object-oriented interface
 * @export
 * @class ExperimentsApi
 * @extends {BaseAPI}
 */
export class ExperimentsApi extends BaseAPI {
  /**
   * Batch delete chaos experiments by uids.
   * @summary Batch delete chaos experiments.
   * @param {string} uids the experiment uids, split with comma. Example: ?uids&#x3D;uid1,uid2
   * @param {'true' | 'false'} [force] force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsDelete(uids: string, force?: 'true' | 'false', options?: AxiosRequestConfig) {
    return ExperimentsApiFp(this.configuration)
      .experimentsDelete(uids, force, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get chaos experiments from k8s clusters in real time.
   * @summary List chaos experiments.
   * @param {string} [namespace] filter exps by namespace
   * @param {string} [name] filter exps by name
   * @param {'PodChaos' | 'NetworkChaos' | 'IOChaos' | 'StressChaos' | 'KernelChaos' | 'TimeChaos' | 'DNSChaos' | 'AWSChaos' | 'GCPChaos' | 'JVMChaos' | 'HTTPChaos'} [kind] filter exps by kind
   * @param {'Injecting' | 'Running' | 'Finished' | 'Paused'} [status] filter exps by status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsGet(
    namespace?: string,
    name?: string,
    kind?:
      | 'PodChaos'
      | 'NetworkChaos'
      | 'IOChaos'
      | 'StressChaos'
      | 'KernelChaos'
      | 'TimeChaos'
      | 'DNSChaos'
      | 'AWSChaos'
      | 'GCPChaos'
      | 'JVMChaos'
      | 'HTTPChaos',
    status?: 'Injecting' | 'Running' | 'Finished' | 'Paused',
    options?: AxiosRequestConfig
  ) {
    return ExperimentsApiFp(this.configuration)
      .experimentsGet(namespace, name, kind, status, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Pause a chaos experiment.
   * @summary Pause a chaos experiment.
   * @param {string} uid the experiment uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsPauseUidPut(uid: string, options?: AxiosRequestConfig) {
    return ExperimentsApiFp(this.configuration)
      .experimentsPauseUidPut(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Pass a JSON object to create a new chaos experiment. The schema for JSON is the same as the YAML schema for the Kubernetes object.
   * @summary Create a new chaos experiment.
   * @param {object} chaos the chaos definition
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsPost(chaos: object, options?: AxiosRequestConfig) {
    return ExperimentsApiFp(this.configuration)
      .experimentsPost(chaos, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start a chaos experiment.
   * @summary Start a chaos experiment.
   * @param {string} uid the experiment uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsStartUidPut(uid: string, options?: AxiosRequestConfig) {
    return ExperimentsApiFp(this.configuration)
      .experimentsStartUidPut(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the status of all experiments.
   * @summary Get the status of all experiments.
   * @param {string} [namespace] namespace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsStateGet(namespace?: string, options?: AxiosRequestConfig) {
    return ExperimentsApiFp(this.configuration)
      .experimentsStateGet(namespace, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the chaos experiment by uid.
   * @summary Delete a chaos experiment.
   * @param {string} uid the experiment uid
   * @param {'true' | 'false'} [force] force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsUidDelete(uid: string, force?: 'true' | 'false', options?: AxiosRequestConfig) {
    return ExperimentsApiFp(this.configuration)
      .experimentsUidDelete(uid, force, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the chaos experiment\'s detail by uid.
   * @summary Get a chaos experiment.
   * @param {string} uid the experiment uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExperimentsApi
   */
  public experimentsUidGet(uid: string, options?: AxiosRequestConfig) {
    return ExperimentsApiFp(this.configuration)
      .experimentsUidGet(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Batch delete schedules by uids.
     * @summary Batch delete schedules.
     * @param {string} uids the schedule uids, split with comma. Example: ?uids&#x3D;uid1,uid2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesDelete: async (uids: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uids' is not null or undefined
      assertParamExists('schedulesDelete', 'uids', uids)
      const localVarPath = `/schedules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (uids !== undefined) {
        localVarQueryParameter['uids'] = uids
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get chaos schedules from k8s cluster in real time.
     * @summary List chaos schedules.
     * @param {string} [namespace] filter schedules by namespace
     * @param {string} [name] filter schedules by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesGet: async (namespace?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/schedules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pause a schedule.
     * @summary Pause a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesPauseUidPut: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('schedulesPauseUidPut', 'uid', uid)
      const localVarPath = `/schedules/pause/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pass a JSON object to create a new schedule. The schema for JSON is the same as the YAML schema for the Kubernetes object.
     * @summary Create a new schedule.
     * @param {V1alpha1Schedule} schedule the schedule definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesPost: async (schedule: V1alpha1Schedule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'schedule' is not null or undefined
      assertParamExists('schedulesPost', 'schedule', schedule)
      const localVarPath = `/schedules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(schedule, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start a schedule.
     * @summary Start a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesStartUidPut: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('schedulesStartUidPut', 'uid', uid)
      const localVarPath = `/schedules/start/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the schedule by uid.
     * @summary Delete a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesUidDelete: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('schedulesUidDelete', 'uid', uid)
      const localVarPath = `/schedules/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the schedule\'s detail by uid.
     * @summary Get a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesUidGet: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('schedulesUidGet', 'uid', uid)
      const localVarPath = `/schedules/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
  return {
    /**
     * Batch delete schedules by uids.
     * @summary Batch delete schedules.
     * @param {string} uids the schedule uids, split with comma. Example: ?uids&#x3D;uid1,uid2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schedulesDelete(
      uids: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesDelete(uids, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get chaos schedules from k8s cluster in real time.
     * @summary List chaos schedules.
     * @param {string} [namespace] filter schedules by namespace
     * @param {string} [name] filter schedules by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schedulesGet(
      namespace?: string,
      name?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleSchedule>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesGet(namespace, name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Pause a schedule.
     * @summary Pause a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schedulesPauseUidPut(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesPauseUidPut(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Pass a JSON object to create a new schedule. The schema for JSON is the same as the YAML schema for the Kubernetes object.
     * @summary Create a new schedule.
     * @param {V1alpha1Schedule} schedule the schedule definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schedulesPost(
      schedule: V1alpha1Schedule,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1alpha1Schedule>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesPost(schedule, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Start a schedule.
     * @summary Start a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schedulesStartUidPut(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesStartUidPut(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the schedule by uid.
     * @summary Delete a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schedulesUidDelete(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesUidDelete(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the schedule\'s detail by uid.
     * @summary Get a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schedulesUidGet(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schedulesUidGet(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SchedulesApiFp(configuration)
  return {
    /**
     * Batch delete schedules by uids.
     * @summary Batch delete schedules.
     * @param {string} uids the schedule uids, split with comma. Example: ?uids&#x3D;uid1,uid2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesDelete(uids: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.schedulesDelete(uids, options).then((request) => request(axios, basePath))
    },
    /**
     * Get chaos schedules from k8s cluster in real time.
     * @summary List chaos schedules.
     * @param {string} [namespace] filter schedules by namespace
     * @param {string} [name] filter schedules by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesGet(namespace?: string, name?: string, options?: any): AxiosPromise<Array<ScheduleSchedule>> {
      return localVarFp.schedulesGet(namespace, name, options).then((request) => request(axios, basePath))
    },
    /**
     * Pause a schedule.
     * @summary Pause a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesPauseUidPut(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.schedulesPauseUidPut(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Pass a JSON object to create a new schedule. The schema for JSON is the same as the YAML schema for the Kubernetes object.
     * @summary Create a new schedule.
     * @param {V1alpha1Schedule} schedule the schedule definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesPost(schedule: V1alpha1Schedule, options?: any): AxiosPromise<V1alpha1Schedule> {
      return localVarFp.schedulesPost(schedule, options).then((request) => request(axios, basePath))
    },
    /**
     * Start a schedule.
     * @summary Start a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesStartUidPut(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.schedulesStartUidPut(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the schedule by uid.
     * @summary Delete a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesUidDelete(uid: string, options?: any): AxiosPromise<UtilsResponse> {
      return localVarFp.schedulesUidDelete(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the schedule\'s detail by uid.
     * @summary Get a schedule.
     * @param {string} uid the schedule uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schedulesUidGet(uid: string, options?: any): AxiosPromise<ScheduleDetail> {
      return localVarFp.schedulesUidGet(uid, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI {
  /**
   * Batch delete schedules by uids.
   * @summary Batch delete schedules.
   * @param {string} uids the schedule uids, split with comma. Example: ?uids&#x3D;uid1,uid2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchedulesApi
   */
  public schedulesDelete(uids: string, options?: AxiosRequestConfig) {
    return SchedulesApiFp(this.configuration)
      .schedulesDelete(uids, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get chaos schedules from k8s cluster in real time.
   * @summary List chaos schedules.
   * @param {string} [namespace] filter schedules by namespace
   * @param {string} [name] filter schedules by name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchedulesApi
   */
  public schedulesGet(namespace?: string, name?: string, options?: AxiosRequestConfig) {
    return SchedulesApiFp(this.configuration)
      .schedulesGet(namespace, name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Pause a schedule.
   * @summary Pause a schedule.
   * @param {string} uid the schedule uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchedulesApi
   */
  public schedulesPauseUidPut(uid: string, options?: AxiosRequestConfig) {
    return SchedulesApiFp(this.configuration)
      .schedulesPauseUidPut(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Pass a JSON object to create a new schedule. The schema for JSON is the same as the YAML schema for the Kubernetes object.
   * @summary Create a new schedule.
   * @param {V1alpha1Schedule} schedule the schedule definition
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchedulesApi
   */
  public schedulesPost(schedule: V1alpha1Schedule, options?: AxiosRequestConfig) {
    return SchedulesApiFp(this.configuration)
      .schedulesPost(schedule, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start a schedule.
   * @summary Start a schedule.
   * @param {string} uid the schedule uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchedulesApi
   */
  public schedulesStartUidPut(uid: string, options?: AxiosRequestConfig) {
    return SchedulesApiFp(this.configuration)
      .schedulesStartUidPut(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the schedule by uid.
   * @summary Delete a schedule.
   * @param {string} uid the schedule uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchedulesApi
   */
  public schedulesUidDelete(uid: string, options?: AxiosRequestConfig) {
    return SchedulesApiFp(this.configuration)
      .schedulesUidDelete(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the schedule\'s detail by uid.
   * @summary Get a schedule.
   * @param {string} uid the schedule uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchedulesApi
   */
  public schedulesUidGet(uid: string, options?: AxiosRequestConfig) {
    return SchedulesApiFp(this.configuration)
      .schedulesUidGet(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get status check templates from k8s cluster in real time.
     * @summary List status check templates.
     * @param {string} [namespace] filter status check templates by namespace
     * @param {string} [name] filter status check templates by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksGet: async (
      namespace?: string,
      name?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/templates/statuschecks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TemplateApiAxiosParamCreator(configuration)
  return {
    /**
     * Get status check templates from k8s cluster in real time.
     * @summary List status check templates.
     * @param {string} [namespace] filter status check templates by namespace
     * @param {string} [name] filter status check templates by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async templatesStatuschecksGet(
      namespace?: string,
      name?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateStatusCheckTemplateBase>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.templatesStatuschecksGet(namespace, name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TemplateApiFp(configuration)
  return {
    /**
     * Get status check templates from k8s cluster in real time.
     * @summary List status check templates.
     * @param {string} [namespace] filter status check templates by namespace
     * @param {string} [name] filter status check templates by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksGet(
      namespace?: string,
      name?: string,
      options?: any
    ): AxiosPromise<Array<TemplateStatusCheckTemplateBase>> {
      return localVarFp.templatesStatuschecksGet(namespace, name, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
  /**
   * Get status check templates from k8s cluster in real time.
   * @summary List status check templates.
   * @param {string} [namespace] filter status check templates by namespace
   * @param {string} [name] filter status check templates by name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplateApi
   */
  public templatesStatuschecksGet(namespace?: string, name?: string, options?: AxiosRequestConfig) {
    return TemplateApiFp(this.configuration)
      .templatesStatuschecksGet(namespace, name, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Pass a JSON object to create a new status check template.
     * @summary Create a new status check template.
     * @param {TemplateStatusCheckTemplate} statuscheck the status check definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksPost: async (
      statuscheck: TemplateStatusCheckTemplate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'statuscheck' is not null or undefined
      assertParamExists('templatesStatuschecksPost', 'statuscheck', statuscheck)
      const localVarPath = `/templates/statuschecks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(statuscheck, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the status check template by namespaced name.
     * @summary Delete a status check template.
     * @param {string} namespace the namespace of status check templates
     * @param {string} name the name of status check templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksStatuscheckDelete: async (
      namespace: string,
      name: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('templatesStatuschecksStatuscheckDelete', 'namespace', namespace)
      // verify required parameter 'name' is not null or undefined
      assertParamExists('templatesStatuschecksStatuscheckDelete', 'name', name)
      const localVarPath = `/templates/statuschecks/statuscheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the status check template\'s detail by namespaced name.
     * @summary Get a status check template.
     * @param {string} namespace the namespace of status check templates
     * @param {string} name the name of status check templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksStatuscheckGet: async (
      namespace: string,
      name: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('templatesStatuschecksStatuscheckGet', 'namespace', namespace)
      // verify required parameter 'name' is not null or undefined
      assertParamExists('templatesStatuschecksStatuscheckGet', 'name', name)
      const localVarPath = `/templates/statuschecks/statuscheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update a status check template by namespaced name.
     * @summary Update a status check template.
     * @param {TemplateStatusCheckTemplate} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksStatuscheckPut: async (
      request: TemplateStatusCheckTemplate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('templatesStatuschecksStatuscheckPut', 'request', request)
      const localVarPath = `/templates/statuschecks/statuscheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
  return {
    /**
     * Pass a JSON object to create a new status check template.
     * @summary Create a new status check template.
     * @param {TemplateStatusCheckTemplate} statuscheck the status check definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async templatesStatuschecksPost(
      statuscheck: TemplateStatusCheckTemplate,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateStatusCheckTemplate>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.templatesStatuschecksPost(statuscheck, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the status check template by namespaced name.
     * @summary Delete a status check template.
     * @param {string} namespace the namespace of status check templates
     * @param {string} name the name of status check templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async templatesStatuschecksStatuscheckDelete(
      namespace: string,
      name: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtilsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.templatesStatuschecksStatuscheckDelete(
        namespace,
        name,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get the status check template\'s detail by namespaced name.
     * @summary Get a status check template.
     * @param {string} namespace the namespace of status check templates
     * @param {string} name the name of status check templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async templatesStatuschecksStatuscheckGet(
      namespace: string,
      name: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateStatusCheckTemplateDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.templatesStatuschecksStatuscheckGet(
        namespace,
        name,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update a status check template by namespaced name.
     * @summary Update a status check template.
     * @param {TemplateStatusCheckTemplate} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async templatesStatuschecksStatuscheckPut(
      request: TemplateStatusCheckTemplate,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateStatusCheckTemplate>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.templatesStatuschecksStatuscheckPut(request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TemplatesApiFp(configuration)
  return {
    /**
     * Pass a JSON object to create a new status check template.
     * @summary Create a new status check template.
     * @param {TemplateStatusCheckTemplate} statuscheck the status check definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksPost(
      statuscheck: TemplateStatusCheckTemplate,
      options?: any
    ): AxiosPromise<TemplateStatusCheckTemplate> {
      return localVarFp.templatesStatuschecksPost(statuscheck, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the status check template by namespaced name.
     * @summary Delete a status check template.
     * @param {string} namespace the namespace of status check templates
     * @param {string} name the name of status check templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksStatuscheckDelete(
      namespace: string,
      name: string,
      options?: any
    ): AxiosPromise<UtilsResponse> {
      return localVarFp
        .templatesStatuschecksStatuscheckDelete(namespace, name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get the status check template\'s detail by namespaced name.
     * @summary Get a status check template.
     * @param {string} namespace the namespace of status check templates
     * @param {string} name the name of status check templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksStatuscheckGet(
      namespace: string,
      name: string,
      options?: any
    ): AxiosPromise<TemplateStatusCheckTemplateDetail> {
      return localVarFp
        .templatesStatuschecksStatuscheckGet(namespace, name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update a status check template by namespaced name.
     * @summary Update a status check template.
     * @param {TemplateStatusCheckTemplate} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    templatesStatuschecksStatuscheckPut(
      request: TemplateStatusCheckTemplate,
      options?: any
    ): AxiosPromise<TemplateStatusCheckTemplate> {
      return localVarFp
        .templatesStatuschecksStatuscheckPut(request, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
  /**
   * Pass a JSON object to create a new status check template.
   * @summary Create a new status check template.
   * @param {TemplateStatusCheckTemplate} statuscheck the status check definition
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplatesApi
   */
  public templatesStatuschecksPost(statuscheck: TemplateStatusCheckTemplate, options?: AxiosRequestConfig) {
    return TemplatesApiFp(this.configuration)
      .templatesStatuschecksPost(statuscheck, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the status check template by namespaced name.
   * @summary Delete a status check template.
   * @param {string} namespace the namespace of status check templates
   * @param {string} name the name of status check templates
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplatesApi
   */
  public templatesStatuschecksStatuscheckDelete(namespace: string, name: string, options?: AxiosRequestConfig) {
    return TemplatesApiFp(this.configuration)
      .templatesStatuschecksStatuscheckDelete(namespace, name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the status check template\'s detail by namespaced name.
   * @summary Get a status check template.
   * @param {string} namespace the namespace of status check templates
   * @param {string} name the name of status check templates
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplatesApi
   */
  public templatesStatuschecksStatuscheckGet(namespace: string, name: string, options?: AxiosRequestConfig) {
    return TemplatesApiFp(this.configuration)
      .templatesStatuschecksStatuscheckGet(namespace, name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update a status check template by namespaced name.
   * @summary Update a status check template.
   * @param {TemplateStatusCheckTemplate} request Request body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplatesApi
   */
  public templatesStatuschecksStatuscheckPut(request: TemplateStatusCheckTemplate, options?: AxiosRequestConfig) {
    return TemplatesApiFp(this.configuration)
      .templatesStatuschecksStatuscheckPut(request, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * List workflows from Kubernetes cluster.
     * @summary List workflows from Kubernetes cluster.
     * @param {string} [namespace] namespace, given empty string means list from all namespace
     * @param {'Initializing' | 'Running' | 'Errored' | 'Finished'} [status] status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsGet: async (
      namespace?: string,
      status?: 'Initializing' | 'Running' | 'Errored' | 'Finished',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/workflows`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Parse the rendered task back to the original request
     * @summary Parse the rendered task back to the original request
     * @param {V1alpha1Template} request Rendered Task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsParseTaskHttpPost: async (
      request: V1alpha1Template,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('workflowsParseTaskHttpPost', 'request', request)
      const localVarPath = `/workflows/parse-task/http`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new workflow.
     * @summary Create a new workflow.
     * @param {V1alpha1Workflow} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsPost: async (request: V1alpha1Workflow, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('workflowsPost', 'request', request)
      const localVarPath = `/workflows`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Render a task which sends HTTP request
     * @summary Render a task which sends HTTP request
     * @param {CurlRequestForm} request Origin HTTP Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsRenderTaskHttpPost: async (
      request: CurlRequestForm,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('workflowsRenderTaskHttpPost', 'request', request)
      const localVarPath = `/workflows/render-task/http`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete the specified workflow.
     * @summary Delete the specified workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUidDelete: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('workflowsUidDelete', 'uid', uid)
      const localVarPath = `/workflows/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get detailed information about the specified workflow. If that object is not existed in kubernetes, it will only return ths persisted data in the database.
     * @summary Get detailed information about the specified workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUidGet: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('workflowsUidGet', 'uid', uid)
      const localVarPath = `/workflows/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update a workflow.
     * @summary Update a workflow.
     * @param {string} uid uid
     * @param {V1alpha1Workflow} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUidPut: async (
      uid: string,
      request: V1alpha1Workflow,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists('workflowsUidPut', 'uid', uid)
      // verify required parameter 'request' is not null or undefined
      assertParamExists('workflowsUidPut', 'request', request)
      const localVarPath = `/workflows/{uid}`.replace(`{${'uid'}}`, encodeURIComponent(String(uid)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Validate the given template is a valid rendered HTTP Task
     * @summary Validate the given template is a valid rendered HTTP Task
     * @param {V1alpha1Template} request Rendered Task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsValidateTaskHttpPost: async (
      request: V1alpha1Template,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'request' is not null or undefined
      assertParamExists('workflowsValidateTaskHttpPost', 'request', request)
      const localVarPath = `/workflows/validate-task/http`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
  return {
    /**
     * List workflows from Kubernetes cluster.
     * @summary List workflows from Kubernetes cluster.
     * @param {string} [namespace] namespace, given empty string means list from all namespace
     * @param {'Initializing' | 'Running' | 'Errored' | 'Finished'} [status] status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsGet(
      namespace?: string,
      status?: 'Initializing' | 'Running' | 'Errored' | 'Finished',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoreWorkflowMeta>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsGet(namespace, status, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Parse the rendered task back to the original request
     * @summary Parse the rendered task back to the original request
     * @param {V1alpha1Template} request Rendered Task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsParseTaskHttpPost(
      request: V1alpha1Template,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurlRequestForm>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsParseTaskHttpPost(request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Create a new workflow.
     * @summary Create a new workflow.
     * @param {V1alpha1Workflow} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsPost(
      request: V1alpha1Workflow,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreWorkflowDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsPost(request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Render a task which sends HTTP request
     * @summary Render a task which sends HTTP request
     * @param {CurlRequestForm} request Origin HTTP Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsRenderTaskHttpPost(
      request: CurlRequestForm,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1alpha1Template>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsRenderTaskHttpPost(request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete the specified workflow.
     * @summary Delete the specified workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsUidDelete(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStatusResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsUidDelete(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get detailed information about the specified workflow. If that object is not existed in kubernetes, it will only return ths persisted data in the database.
     * @summary Get detailed information about the specified workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsUidGet(
      uid: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreWorkflowDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsUidGet(uid, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update a workflow.
     * @summary Update a workflow.
     * @param {string} uid uid
     * @param {V1alpha1Workflow} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsUidPut(
      uid: string,
      request: V1alpha1Workflow,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreWorkflowDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsUidPut(uid, request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Validate the given template is a valid rendered HTTP Task
     * @summary Validate the given template is a valid rendered HTTP Task
     * @param {V1alpha1Template} request Rendered Task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsValidateTaskHttpPost(
      request: V1alpha1Template,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsValidateTaskHttpPost(request, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = WorkflowsApiFp(configuration)
  return {
    /**
     * List workflows from Kubernetes cluster.
     * @summary List workflows from Kubernetes cluster.
     * @param {string} [namespace] namespace, given empty string means list from all namespace
     * @param {'Initializing' | 'Running' | 'Errored' | 'Finished'} [status] status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsGet(
      namespace?: string,
      status?: 'Initializing' | 'Running' | 'Errored' | 'Finished',
      options?: any
    ): AxiosPromise<Array<CoreWorkflowMeta>> {
      return localVarFp.workflowsGet(namespace, status, options).then((request) => request(axios, basePath))
    },
    /**
     * Parse the rendered task back to the original request
     * @summary Parse the rendered task back to the original request
     * @param {V1alpha1Template} request Rendered Task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsParseTaskHttpPost(request: V1alpha1Template, options?: any): AxiosPromise<CurlRequestForm> {
      return localVarFp.workflowsParseTaskHttpPost(request, options).then((request) => request(axios, basePath))
    },
    /**
     * Create a new workflow.
     * @summary Create a new workflow.
     * @param {V1alpha1Workflow} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsPost(request: V1alpha1Workflow, options?: any): AxiosPromise<CoreWorkflowDetail> {
      return localVarFp.workflowsPost(request, options).then((request) => request(axios, basePath))
    },
    /**
     * Render a task which sends HTTP request
     * @summary Render a task which sends HTTP request
     * @param {CurlRequestForm} request Origin HTTP Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsRenderTaskHttpPost(request: CurlRequestForm, options?: any): AxiosPromise<V1alpha1Template> {
      return localVarFp.workflowsRenderTaskHttpPost(request, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete the specified workflow.
     * @summary Delete the specified workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUidDelete(uid: string, options?: any): AxiosPromise<WorkflowStatusResponse> {
      return localVarFp.workflowsUidDelete(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Get detailed information about the specified workflow. If that object is not existed in kubernetes, it will only return ths persisted data in the database.
     * @summary Get detailed information about the specified workflow.
     * @param {string} uid uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUidGet(uid: string, options?: any): AxiosPromise<CoreWorkflowDetail> {
      return localVarFp.workflowsUidGet(uid, options).then((request) => request(axios, basePath))
    },
    /**
     * Update a workflow.
     * @summary Update a workflow.
     * @param {string} uid uid
     * @param {V1alpha1Workflow} request Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUidPut(uid: string, request: V1alpha1Workflow, options?: any): AxiosPromise<CoreWorkflowDetail> {
      return localVarFp.workflowsUidPut(uid, request, options).then((request) => request(axios, basePath))
    },
    /**
     * Validate the given template is a valid rendered HTTP Task
     * @summary Validate the given template is a valid rendered HTTP Task
     * @param {V1alpha1Template} request Rendered Task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsValidateTaskHttpPost(request: V1alpha1Template, options?: any): AxiosPromise<boolean> {
      return localVarFp.workflowsValidateTaskHttpPost(request, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
  /**
   * List workflows from Kubernetes cluster.
   * @summary List workflows from Kubernetes cluster.
   * @param {string} [namespace] namespace, given empty string means list from all namespace
   * @param {'Initializing' | 'Running' | 'Errored' | 'Finished'} [status] status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsGet(
    namespace?: string,
    status?: 'Initializing' | 'Running' | 'Errored' | 'Finished',
    options?: AxiosRequestConfig
  ) {
    return WorkflowsApiFp(this.configuration)
      .workflowsGet(namespace, status, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Parse the rendered task back to the original request
   * @summary Parse the rendered task back to the original request
   * @param {V1alpha1Template} request Rendered Task
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsParseTaskHttpPost(request: V1alpha1Template, options?: AxiosRequestConfig) {
    return WorkflowsApiFp(this.configuration)
      .workflowsParseTaskHttpPost(request, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new workflow.
   * @summary Create a new workflow.
   * @param {V1alpha1Workflow} request Request body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsPost(request: V1alpha1Workflow, options?: AxiosRequestConfig) {
    return WorkflowsApiFp(this.configuration)
      .workflowsPost(request, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Render a task which sends HTTP request
   * @summary Render a task which sends HTTP request
   * @param {CurlRequestForm} request Origin HTTP Request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsRenderTaskHttpPost(request: CurlRequestForm, options?: AxiosRequestConfig) {
    return WorkflowsApiFp(this.configuration)
      .workflowsRenderTaskHttpPost(request, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete the specified workflow.
   * @summary Delete the specified workflow.
   * @param {string} uid uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsUidDelete(uid: string, options?: AxiosRequestConfig) {
    return WorkflowsApiFp(this.configuration)
      .workflowsUidDelete(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get detailed information about the specified workflow. If that object is not existed in kubernetes, it will only return ths persisted data in the database.
   * @summary Get detailed information about the specified workflow.
   * @param {string} uid uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsUidGet(uid: string, options?: AxiosRequestConfig) {
    return WorkflowsApiFp(this.configuration)
      .workflowsUidGet(uid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update a workflow.
   * @summary Update a workflow.
   * @param {string} uid uid
   * @param {V1alpha1Workflow} request Request body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsUidPut(uid: string, request: V1alpha1Workflow, options?: AxiosRequestConfig) {
    return WorkflowsApiFp(this.configuration)
      .workflowsUidPut(uid, request, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Validate the given template is a valid rendered HTTP Task
   * @summary Validate the given template is a valid rendered HTTP Task
   * @param {V1alpha1Template} request Rendered Task
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkflowsApi
   */
  public workflowsValidateTaskHttpPost(request: V1alpha1Template, options?: AxiosRequestConfig) {
    return WorkflowsApiFp(this.configuration)
      .workflowsValidateTaskHttpPost(request, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
